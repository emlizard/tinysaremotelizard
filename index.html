<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NanoVNA/tinySA Î¶¨Î™®Ìä∏ ÎØ∏Îü¨ÎßÅ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a3a);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .device-selector {
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }

        .screen-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .device-screen {
            background: #000;
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            position: relative;
            cursor: crosshair;
            transition: transform 0.3s ease;
        }

        .device-screen canvas {
            display: block;
            border-radius: 7px;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 1.2rem;
            border-radius: 7px;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .control-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            color: #64b5f6;
            margin-bottom: 1rem;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        button:hover {
            background: linear-gradient(45deg, #1976d2, #1565c0);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(25, 118, 210, 0.4);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .hotkeys {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.6;
        }

        .hotkeys h4 {
            color: #64b5f6;
            margin-bottom: 0.5rem;
        }

        .hotkey {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .capture-info {
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #ccc;
        }

        .device-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .value {
            color: #64b5f6;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                height: 200px;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üì° NanoVNA/tinySA Î¶¨Î™®Ìä∏ ÎØ∏Îü¨ÎßÅ</h1>
        <div class="controls">
            <select class="device-selector" id="deviceType">
                <option value="nanovna">NanoVNA-H</option>
                <option value="nanovna-h4">NanoVNA-H4</option>
                <option value="tinysa">tinySA</option>
                <option value="tinysa-ultra">tinySA Ultra</option>
                <option value="tinypfa">tinyPFA</option>
            </select>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="connectionStatus">Ïó∞Í≤∞ ÏïàÎê®</span>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="screen-area">
            <div class="device-screen" id="deviceScreen">
                <canvas id="screenCanvas" width="320" height="240"></canvas>
                <div class="screen-overlay" id="screenOverlay">
                    <div>üîå Ïû•ÎπÑÎ•º Ïó∞Í≤∞ÌïòÏÑ∏Ïöî</div>
                    <div style="font-size: 0.9rem; margin-top: 1rem; opacity: 0.7;">
                        WebSerial ÏßÄÏõê Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïã§Ï†ú Ïû•ÎπÑ Ïó∞Í≤∞ Í∞ÄÎä•
                    </div>
                </div>
            </div>
            
            <div class="fps-counter" id="fpsCounter">FPS: 0</div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn" title="ÌôïÎåÄ (+)">+</button>
                <button class="zoom-btn" id="zoomOut" title="Ï∂ïÏÜå (-)">-</button>
                <button class="zoom-btn" id="screenshot" title="Ïä§ÌÅ¨Î¶∞ÏÉ∑ (S)">üì∑</button>
            </div>

            <div class="capture-info">
                ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ïû•ÎπÑ Ï°∞Ïûë | ÌÇ§Î≥¥Îìú: +/- Ï§å, S Ïä§ÌÅ¨Î¶∞ÏÉ∑, ESC Ï¢ÖÎ£å
            </div>
        </div>

        <div class="control-panel">
            <div class="section">
                <h3>üîå Ïû•ÎπÑ Ïó∞Í≤∞</h3>
                <button id="connectBtn">Ïû•ÎπÑ Ïó∞Í≤∞</button>
                <button id="disconnectBtn" disabled>Ïó∞Í≤∞ Ìï¥Ï†ú</button>
                <button id="pauseBtn" disabled>ÌôîÎ©¥ ÏùºÏãúÏ†ïÏßÄ</button>
                <button id="resumeBtn" disabled>ÌôîÎ©¥ Ïû¨Í∞ú</button>
            </div>

            <div class="device-info" id="deviceInfo" style="display: none;">
                <h4 style="color: #64b5f6; margin-bottom: 0.5rem;">Ïû•ÎπÑ Ï†ïÎ≥¥</h4>
                <div class="info-row">
                    <span>Ìï¥ÏÉÅÎèÑ:</span>
                    <span class="value" id="resolution">320√ó240</span>
                </div>
                <div class="info-row">
                    <span>FPS:</span>
                    <span class="value" id="fpsValue">0</span>
                </div>
                <div class="info-row">
                    <span>ÏïïÏ∂ï:</span>
                    <span class="value" id="compression">RLE</span>
                </div>
                <div class="info-row">
                    <span>Î∞∞ÌÑ∞Î¶¨:</span>
                    <span class="value" id="battery">-</span>
                </div>
            </div>

            <div class="section">
                <h3>‚öôÔ∏è ÌôîÎ©¥ ÏÑ§Ï†ï</h3>
                <button id="invertBtn">ÏÉâÏÉÅ Î∞òÏ†Ñ</button>
                <button id="fitScreenBtn">ÌôîÎ©¥ ÎßûÏ∂§</button>
                <button id="resetZoomBtn">Ï§å Î¶¨ÏÖã</button>
            </div>

            <div class="section">
                <h3>üì∏ Ï∫°Ï≤ò</h3>
                <button id="singleCaptureBtn">Îã®Ïùº Ï∫°Ï≤ò</button>
                <button id="continuousCaptureBtn">Ïó∞ÏÜç Ï∫°Ï≤ò ÏãúÏûë</button>
                <button id="saveScreenshotBtn">Ïä§ÌÅ¨Î¶∞ÏÉ∑ Ï†ÄÏû•</button>
            </div>

            <div class="section">
                <h3>üîß ÏãúÏä§ÌÖú ÏßÑÎã®</h3>
                <button id="diagnosisBtn">ÏãúÏä§ÌÖú ÌôòÍ≤Ω Ï≤¥ÌÅ¨</button>
                <button id="listPortsBtn">ÏÇ¨Ïö©Í∞ÄÎä• Ìè¨Ìä∏ ÌôïÏù∏</button>
                <button id="testConnectionBtn">Ïó∞Í≤∞ ÌÖåÏä§Ìä∏</button>
            </div>

            <div class="hotkeys">
                <h4>üéÆ Îã®Ï∂ïÌÇ§</h4>
                <div class="hotkey">
                    <span>ÌôïÎåÄ</span>
                    <span class="key">+</span>
                </div>
                <div class="hotkey">
                    <span>Ï∂ïÏÜå</span>
                    <span class="key">-</span>
                </div>
                <div class="hotkey">
                    <span>Ïä§ÌÅ¨Î¶∞ÏÉ∑</span>
                    <span class="key">S</span>
                </div>
                <div class="hotkey">
                    <span>Ï¢ÖÎ£å</span>
                    <span class="key">ESC</span>
                </div>
                <div class="hotkey">
                    <span>ÏùºÏãúÏ†ïÏßÄ</span>
                    <span class="key">SPACE</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NanoVNARemoteController {
            constructor() {
                this.isConnected = false;
                this.serialPort = null;
                this.canvas = document.getElementById('screenCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.deviceType = 'nanovna';
                this.zoom = 2;
                this.isCapturing = false;
                this.isPaused = false;
                this.invertColors = false;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.screenData = null;
                this.simulationMode = !('serial' in navigator);
                this.availableDevices = [];
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupKeyboardShortcuts();
                this.updateDeviceResolution();
                
                if (this.simulationMode) {
                    this.startSimulation();
                } else {
                    this.startDeviceMonitoring();
                }
            }

            async startDeviceMonitoring() {
                // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ïó∞Í≤∞Îêú Ïû•ÎπÑ ÌôïÏù∏
                await this.checkAvailableDevices();
                
                // USB Ïû•ÎπÑ Ïó∞Í≤∞/Ìï¥Ï†ú Í∞êÏßÄ
                if ('serial' in navigator) {
                    navigator.serial.addEventListener('connect', (event) => {
                        console.log('Ïû•ÎπÑ Ïó∞Í≤∞Îê®:', event.port);
                        this.checkAvailableDevices();
                    });
                    
                    navigator.serial.addEventListener('disconnect', (event) => {
                        console.log('Ïû•ÎπÑ Ïó∞Í≤∞ Ìï¥Ï†úÎê®:', event.port);
                        this.checkAvailableDevices();
                        if (event.port === this.serialPort) {
                            this.disconnect();
                        }
                    });
                }
            }

            async checkAvailableDevices() {
                if (this.simulationMode) return;
                
                try {
                    const ports = await navigator.serial.getPorts();
                    this.availableDevices = [];
                    
                    for (const port of ports) {
                        const info = port.getInfo();
                        if (info.usbVendorId === 0x0483 && info.usbProductId === 0x5740) {
                            this.availableDevices.push({
                                port: port,
                                vendorId: info.usbVendorId,
                                productId: info.usbProductId
                            });
                        }
                    }
                    
                    this.updateDeviceStatus();
                } catch (error) {
                    console.error('Ïû•ÎπÑ ÌôïÏù∏ Ïã§Ìå®:', error);
                }
            }

            updateDeviceStatus() {
                const hasDevice = this.availableDevices.length > 0;
                
                if (hasDevice && !this.isConnected) {
                    this.elements.connectionStatus.textContent = `${this.availableDevices.length}Í∞ú Ïû•ÎπÑ Í∞êÏßÄÎê®`;
                    this.elements.connectBtn.textContent = 'ÏûêÎèô Ïó∞Í≤∞';
                } else if (!hasDevice && !this.isConnected) {
                    this.elements.connectionStatus.textContent = 'Ïû•ÎπÑ ÏóÜÏùå';
                    this.elements.connectBtn.textContent = 'Ïû•ÎπÑ Ïó∞Í≤∞';
                }
            }

            initializeElements() {
                this.elements = {
                    deviceType: document.getElementById('deviceType'),
                    statusDot: document.getElementById('statusDot'),
                    connectionStatus: document.getElementById('connectionStatus'),
                    deviceScreen: document.getElementById('deviceScreen'),
                    screenOverlay: document.getElementById('screenOverlay'),
                    fpsCounter: document.getElementById('fpsCounter'),
                    deviceInfo: document.getElementById('deviceInfo'),
                    resolution: document.getElementById('resolution'),
                    fpsValue: document.getElementById('fpsValue'),
                    compression: document.getElementById('compression'),
                    battery: document.getElementById('battery'),
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    resumeBtn: document.getElementById('resumeBtn'),
                    zoomIn: document.getElementById('zoomIn'),
                    zoomOut: document.getElementById('zoomOut'),
                    screenshot: document.getElementById('screenshot'),
                    invertBtn: document.getElementById('invertBtn'),
                    fitScreenBtn: document.getElementById('fitScreenBtn'),
                    resetZoomBtn: document.getElementById('resetZoomBtn'),
                    singleCaptureBtn: document.getElementById('singleCaptureBtn'),
                    continuousCaptureBtn: document.getElementById('continuousCaptureBtn'),
                    saveScreenshotBtn: document.getElementById('saveScreenshotBtn'),
                    diagnosisBtn: document.getElementById('diagnosisBtn'),
                    listPortsBtn: document.getElementById('listPortsBtn'),
                    testConnectionBtn: document.getElementById('testConnectionBtn'),
                    terminal: document.getElementById('terminal')
                };
            }

            setupEventListeners() {
                this.elements.deviceType.addEventListener('change', (e) => {
                    this.deviceType = e.target.value;
                    this.updateDeviceResolution();
                });

                this.elements.connectBtn.addEventListener('click', () => this.connect());
                this.elements.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.elements.pauseBtn.addEventListener('click', () => this.pauseCapture());
                this.elements.resumeBtn.addEventListener('click', () => this.resumeCapture());

                this.elements.zoomIn.addEventListener('click', () => this.zoomIn());
                this.elements.zoomOut.addEventListener('click', () => this.zoomOut());
                this.elements.screenshot.addEventListener('click', () => this.takeScreenshot());

                this.elements.invertBtn.addEventListener('click', () => this.toggleInvert());
                this.elements.fitScreenBtn.addEventListener('click', () => this.fitToScreen());
                this.elements.resetZoomBtn.addEventListener('click', () => this.resetZoom());

                this.elements.singleCaptureBtn.addEventListener('click', () => this.singleCapture());
                this.elements.continuousCaptureBtn.addEventListener('click', () => this.toggleContinuousCapture());
                this.elements.saveScreenshotBtn.addEventListener('click', () => this.saveScreenshot());

                // ÏßÑÎã® Í∏∞Îä•
                this.elements.diagnosisBtn.addEventListener('click', () => this.runDiagnostics());
                this.elements.listPortsBtn.addEventListener('click', () => this.listAvailablePorts());
                this.elements.testConnectionBtn.addEventListener('click', () => this.testConnection());

                // ÌôîÎ©¥ ÌÅ¥Î¶≠ÏúºÎ°ú Ïû•ÎπÑ ÌÑ∞Ïπò ÏãúÎÆ¨Î†àÏù¥ÏÖò
                this.canvas.addEventListener('click', (e) => this.handleScreenClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case '+':
                        case '=':
                            e.preventDefault();
                            this.zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            this.zoomOut();
                            break;
                        case 's':
                        case 'S':
                            e.preventDefault();
                            this.takeScreenshot();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.disconnect();
                            break;
                        case ' ':
                            e.preventDefault();
                            if (this.isPaused) {
                                this.resumeCapture();
                            } else {
                                this.pauseCapture();
                            }
                            break;
                    }
                });
            }

            updateDeviceResolution() {
                const deviceConfig = this.getDeviceConfig();
                
                this.canvas.width = deviceConfig.width;
                this.canvas.height = deviceConfig.height;
                this.elements.resolution.textContent = `${deviceConfig.width}√ó${deviceConfig.height}`;
                
                // Ìó§ÎçîÏóê ÏÑ†ÌÉùÎêú Ïû•ÎπÑÎ™Ö ÌëúÏãú
                const headerTitle = document.querySelector('.header h1');
                headerTitle.textContent = `üì° ${deviceConfig.name} Î¶¨Î™®Ìä∏ ÎØ∏Îü¨ÎßÅ`;
                
                this.updateScreenSize();
                console.log(`Ïû•ÎπÑ Î≥ÄÍ≤Ω: ${deviceConfig.name} (${deviceConfig.width}√ó${deviceConfig.height})`);
            }

            updateScreenSize() {
                const scale = this.zoom;
                this.elements.deviceScreen.style.transform = `scale(${scale})`;
            }

            getDeviceConfig() {
                const configs = {
                    'nanovna': {
                        name: 'NanoVNA-H',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    },
                    'nanovna-h4': {
                        name: 'NanoVNA-H4',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320
                    },
                    'tinysa': {
                        name: 'tinySA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    },
                    'tinysa-ultra': {
                        name: 'tinySA Ultra',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320
                    },
                    'tinypfa': {
                        name: 'tinyPFA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    }
                };
                return configs[this.deviceType];
            }

            async autoDetectDevice() {
                if (this.simulationMode) return null;
                
                try {
                    // Ïù¥ÎØ∏ Í∂åÌïúÏù¥ Î∂ÄÏó¨Îêú Ìè¨Ìä∏Îì§ ÌôïÏù∏
                    const ports = await navigator.serial.getPorts();
                    
                    for (const port of ports) {
                        const info = port.getInfo();
                        const deviceConfig = this.getDeviceConfig();
                        
                        // VID/PID Îß§Ïπ≠ ÌôïÏù∏
                        if (info.usbVendorId === deviceConfig.vendorId && 
                            info.usbProductId === deviceConfig.productId) {
                            console.log(`Ïû•ÎπÑ ÏûêÎèô Í∞êÏßÄÎê®: VID=${info.usbVendorId.toString(16)}, PID=${info.usbProductId.toString(16)}`);
                            return port;
                        }
                    }
                    
                    console.log('Í∏∞Ï°¥Ïóê Ïó∞Í≤∞Îêú Ïû•ÎπÑÍ∞Ä ÏóÜÏäµÎãàÎã§. ÏàòÎèô ÏÑ†ÌÉùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
                    return null;
                } catch (error) {
                    console.error('ÏûêÎèô Í∞êÏßÄ Ïã§Ìå®:', error);
                    return null;
                }
            }

            async connect() {
                this.elements.connectBtn.disabled = true;
                this.elements.connectionStatus.textContent = 'Ïû•ÎπÑ Í∞êÏßÄ Ï§ë...';
                
                const deviceConfig = this.getDeviceConfig();

                if (!this.simulationMode) {
                    try {
                        // 1Îã®Í≥Ñ: ÏûêÎèô Ïû•ÎπÑ Í∞êÏßÄ ÏãúÎèÑ
                        let detectedPort = await this.autoDetectDevice();
                        
                        if (detectedPort) {
                            // ÏûêÎèô Í∞êÏßÄÎêú Ïû•ÎπÑÎ°ú Ïó∞Í≤∞
                            this.serialPort = detectedPort;
                            this.elements.connectionStatus.textContent = 'ÏûêÎèô Í∞êÏßÄÎêú Ïû•ÎπÑÏóê Ïó∞Í≤∞ Ï§ë...';
                        } else {
                            // 2Îã®Í≥Ñ: ÏàòÎèô Ïû•ÎπÑ ÏÑ†ÌÉù
                            this.elements.connectionStatus.textContent = 'Ïû•ÎπÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî...';
                            this.serialPort = await navigator.serial.requestPort({
                                filters: [{ 
                                    usbVendorId: deviceConfig.vendorId, 
                                    usbProductId: deviceConfig.productId 
                                }]
                            });
                            this.elements.connectionStatus.textContent = 'ÏÑ†ÌÉùÎêú Ïû•ÎπÑÏóê Ïó∞Í≤∞ Ï§ë...';
                        }

                        // Ìè¨Ìä∏ Ïó¥Í∏∞
                        await this.serialPort.open({
                            baudRate: deviceConfig.baudRate,
                            dataBits: 8,
                            stopBits: 1,
                            parity: 'none'
                        });

                        // Ïû•ÎπÑ ÌÉÄÏûÖ ÌôïÏù∏
                        await this.verifyDeviceType();
                        
                        this.isConnected = true;
                        this.startRealCapture();
                    } catch (error) {
                        console.error('Ïó∞Í≤∞ Ïã§Ìå®:', error);
                        this.elements.connectionStatus.textContent = `Ïó∞Í≤∞ Ïã§Ìå®: ${error.message}`;
                        this.elements.connectBtn.disabled = false;
                        return;
                    }
                } else {
                    // ÏãúÎÆ¨Î†àÏù¥ÏÖò Î™®Îìú
                    setTimeout(() => {
                        this.isConnected = true;
                        this.updateConnectionStatus();
                        this.startSimulation();
                    }, 1000);
                }

                this.updateConnectionStatus();
            }

            async verifyDeviceType() {
                if (!this.serialPort) return;
                
                try {
                    const encoder = new TextEncoder();
                    const decoder = new TextDecoder();
                    
                    // Ïû•ÎπÑ Ï†ïÎ≥¥ ÏöîÏ≤≠
                    const writer = this.serialPort.writable.getWriter();
                    await writer.write(encoder.encode('info\r\n'));
                    writer.releaseLock();

                    // ÏùëÎãµ ÏùΩÍ∏∞
                    const reader = this.serialPort.readable.getReader();
                    const { value } = await reader.read();
                    const response = decoder.decode(value);
                    reader.releaseLock();

                    console.log('Ïû•ÎπÑ Ï†ïÎ≥¥:', response);
                    
                    // ÏùëÎãµÏóêÏÑú Ïû•ÎπÑ ÌÉÄÏûÖ ÌôïÏù∏
                    if (response.includes('tinySA') && this.deviceType.includes('nanovna')) {
                        throw new Error('ÏÑ†ÌÉùÎêú Ïû•ÎπÑ ÌÉÄÏûÖÍ≥º Ïã§Ï†ú Ïû•ÎπÑÍ∞Ä Îã§Î¶ÖÎãàÎã§. tinySAÍ∞Ä Ïó∞Í≤∞Îê®');
                    } else if (response.includes('NanoVNA') && this.deviceType.includes('tinysa')) {
                        throw new Error('ÏÑ†ÌÉùÎêú Ïû•ÎπÑ ÌÉÄÏûÖÍ≥º Ïã§Ï†ú Ïû•ÎπÑÍ∞Ä Îã§Î¶ÖÎãàÎã§. NanoVNAÍ∞Ä Ïó∞Í≤∞Îê®');
                    }
                    
                } catch (error) {
                    console.warn('Ïû•ÎπÑ ÌÉÄÏûÖ ÌôïÏù∏ Ïã§Ìå®:', error);
                    // ÌôïÏù∏ Ïã§Ìå®ÏãúÏóêÎèÑ Ïó∞Í≤∞ÏùÄ ÏßÑÌñâ (ÏùºÎ∂Ä Ïû•ÎπÑÏóêÏÑú info Î™ÖÎ†π ÎØ∏ÏßÄÏõê)
                }
            }

            async disconnect() {
                if (this.serialPort && !this.simulationMode) {
                    await this.serialPort.close();
                }

                this.isConnected = false;
                this.isCapturing = false;
                this.serialPort = null;
                this.updateConnectionStatus();
            }

            updateConnectionStatus() {
                if (this.isConnected) {
                    this.elements.statusDot.classList.add('connected');
                    this.elements.connectionStatus.textContent = 'Ïó∞Í≤∞Îê®';
                    this.elements.screenOverlay.style.display = 'none';
                    this.elements.deviceInfo.style.display = 'block';
                    this.elements.connectBtn.disabled = true;
                    this.elements.disconnectBtn.disabled = false;
                    this.elements.pauseBtn.disabled = false;
                    this.elements.resumeBtn.disabled = false;
                } else {
                    this.elements.statusDot.classList.remove('connected');
                    this.elements.connectionStatus.textContent = 'Ïó∞Í≤∞ ÏïàÎê®';
                    this.elements.screenOverlay.style.display = 'flex';
                    this.elements.deviceInfo.style.display = 'none';
                    this.elements.connectBtn.disabled = false;
                    this.elements.disconnectBtn.disabled = true;
                    this.elements.pauseBtn.disabled = true;
                    this.elements.resumeBtn.disabled = true;
                }
            }

            async startRealCapture() {
                if (!this.serialPort || !this.isConnected) return;

                this.isCapturing = true;
                this.logToTerminal('üé¨ Ïã§ÏãúÍ∞Ñ ÌôîÎ©¥ Ï∫°Ï≤ò ÏãúÏûë...');
                
                const encoder = new TextEncoder();
                const decoder = new TextDecoder();

                while (this.isCapturing && this.isConnected) {
                    try {
                        if (!this.isPaused) {
                            this.logToTerminal('üì∏ ÌôîÎ©¥ Ï∫°Ï≤ò Ï§ë...');
                            
                            // ÌôîÎ©¥ ÏùºÏãúÏ†ïÏßÄ Î™ÖÎ†π
                            const writer1 = this.serialPort.writable.getWriter();
                            await writer1.write(encoder.encode('pause\r\n'));
                            writer1.releaseLock();
                            await this.delay(100);
                            
                            // ÌôîÎ©¥ Ï∫°Ï≤ò Î™ÖÎ†π (RLE ÏïïÏ∂ï ÏãúÎèÑ)
                            const writer2 = this.serialPort.writable.getWriter();
                            await writer2.write(encoder.encode('capture rle\r\n'));
                            writer2.releaseLock();
                            
                            // ÏùëÎãµ ÏùΩÍ∏∞
                            const reader = this.serialPort.readable.getReader();
                            const timeout = setTimeout(() => reader.cancel(), 3000);
                            
                            try {
                                const { value } = await reader.read();
                                clearTimeout(timeout);
                                
                                if (value && value.length > 0) {
                                    this.logToTerminal(`üì• ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†: ${value.length} bytes`);
                                    await this.parseScreenData(value);
                                } else {
                                    this.logToTerminal('‚ö†Ô∏è  ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå - ÏùºÎ∞ò Ï∫°Ï≤ò ÏãúÎèÑ');
                                    
                                    // RLE Ïã§Ìå®Ïãú ÏùºÎ∞ò Ï∫°Ï≤ò ÏãúÎèÑ
                                    const writer3 = this.serialPort.writable.getWriter();
                                    await writer3.write(encoder.encode('capture\r\n'));
                                    writer3.releaseLock();
                                    
                                    const { value: normalData } = await reader.read();
                                    if (normalData && normalData.length > 0) {
                                        this.logToTerminal(`üì• ÏùºÎ∞ò ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†: ${normalData.length} bytes`);
                                        await this.parseScreenData(normalData);
                                    }
                                }
                            } catch (readError) {
                                this.logToTerminal(`‚ùå Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ Ïã§Ìå®: ${readError.message}`);
                            }
                            
                            reader.releaseLock();
                            
                            // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏ Ïû¨Í∞ú
                            const writer4 = this.serialPort.writable.getWriter();
                            await writer4.write(encoder.encode('resume\r\n'));
                            writer4.releaseLock();
                        }

                        this.updateFPS();
                        await this.delay(200); // 5 FPSÎ°ú Ï†úÌïú
                        
                    } catch (error) {
                        this.logToTerminal(`‚ùå Ï∫°Ï≤ò Ïò§Î•ò: ${error.message}`);
                        await this.delay(1000); // Ïò§Î•òÏãú 1Ï¥à ÎåÄÍ∏∞
                    }
                }
                
                this.logToTerminal('üõë ÌôîÎ©¥ Ï∫°Ï≤ò Ï§ëÏßÄÎê®');
            }

            async parseScreenData(data) {
                try {
                    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÌÖçÏä§Ìä∏Ïù∏ÏßÄ Î∞îÏù¥ÎÑàÎ¶¨Ïù∏ÏßÄ ÌôïÏù∏
                    const decoder = new TextDecoder();
                    const textData = decoder.decode(data);
                    
                    this.logToTerminal(`üîç Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù: ${textData.slice(0, 50)}...`);
                    
                    // RLE Ìó§Îçî ÌôïÏù∏
                    if (data[0] === 0x52 && data[1] === 0x4C && data[2] === 0x45) { // "RLE"
                        this.logToTerminal('üì¶ RLE ÏïïÏ∂ï Îç∞Ïù¥ÌÑ∞ Í∞êÏßÄ');
                        await this.parseRLEData(data.slice(3));
                    } else if (data.length >= 320 * 240 * 2) { // RGB565 Ï∂îÏ†ï
                        this.logToTerminal('üñºÔ∏è  RGB565 Îç∞Ïù¥ÌÑ∞ Í∞êÏßÄ');
                        await this.parseRGB565Data(data);
                    } else {
                        this.logToTerminal('‚ö†Ô∏è  Ïïå Ïàò ÏóÜÎäî Îç∞Ïù¥ÌÑ∞ ÌòïÏãù - ÏãúÎÆ¨Î†àÏù¥ÏÖòÏúºÎ°ú Ï†ÑÌôò');
                        this.generateSimulatedScreen();
                    }
                } catch (error) {
                    this.logToTerminal(`‚ùå ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÌååÏã± Ïã§Ìå®: ${error.message}`);
                    this.generateSimulatedScreen(); // ÌååÏã± Ïã§Ìå®Ïãú ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌëúÏãú
                }
            }

            async parseRLEData(rleData) {
                try {
                    this.logToTerminal('üîì RLE Îç∞Ïù¥ÌÑ∞ ÏïïÏ∂ï Ìï¥Ï†ú Ï§ë...');
                    
                    const deviceConfig = this.getDeviceConfig();
                    const width = deviceConfig.width;
                    const height = deviceConfig.height;
                    
                    // RLE ÏïïÏ∂ï Ìï¥Ï†ú (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
                    const pixels = new Uint8Array(width * height * 4); // RGBA
                    let pixelIndex = 0;
                    let dataIndex = 0;
                    
                    while (dataIndex < rleData.length && pixelIndex < pixels.length) {
                        const count = rleData[dataIndex++];
                        const r = rleData[dataIndex++] || 0;
                        const g = rleData[dataIndex++] || 0;
                        const b = rleData[dataIndex++] || 0;
                        
                        for (let i = 0; i < count && pixelIndex < pixels.length; i++) {
                            pixels[pixelIndex++] = r;
                            pixels[pixelIndex++] = g;
                            pixels[pixelIndex++] = b;
                            pixels[pixelIndex++] = 255; // Alpha
                        }
                    }
                    
                    // CanvasÏóê Í∑∏Î¶¨Í∏∞
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
                    this.ctx.putImageData(imageData, 0, 0);
                    
                    this.logToTerminal('‚úÖ RLE ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÌëúÏãú ÏôÑÎ£å');
                } catch (error) {
                    this.logToTerminal(`‚ùå RLE ÌååÏã± Ïã§Ìå®: ${error.message}`);
                    this.generateSimulatedScreen();
                }
            }

            async parseRGB565Data(rgb565Data) {
                try {
                    this.logToTerminal('üé® RGB565 Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò Ï§ë...');
                    
                    const deviceConfig = this.getDeviceConfig();
                    const width = deviceConfig.width;
                    const height = deviceConfig.height;
                    
                    const pixels = new Uint8Array(width * height * 4); // RGBA
                    
                    for (let i = 0; i < width * height * 2; i += 2) {
                        const rgb565 = (rgb565Data[i] << 8) | rgb565Data[i + 1];
                        const pixelIndex = (i / 2) * 4;
                        
                        // RGB565Î•º RGB888Î°ú Î≥ÄÌôò
                        const r = ((rgb565 >> 11) & 0x1F) << 3;
                        const g = ((rgb565 >> 5) & 0x3F) << 2;
                        const b = (rgb565 & 0x1F) << 3;
                        
                        pixels[pixelIndex] = r;
                        pixels[pixelIndex + 1] = g;
                        pixels[pixelIndex + 2] = b;
                        pixels[pixelIndex + 3] = 255; // Alpha
                    }
                    
                    // CanvasÏóê Í∑∏Î¶¨Í∏∞
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
                    this.ctx.putImageData(imageData, 0, 0);
                    
                    this.logToTerminal('‚úÖ RGB565 ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÌëúÏãú ÏôÑÎ£å');
                } catch (error) {
                    this.logToTerminal(`‚ùå RGB565 ÌååÏã± Ïã§Ìå®: ${error.message}`);
                    this.generateSimulatedScreen();
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            startSimulation() {
                if (!this.isConnected) return;

                this.isCapturing = true;
                const simulate = () => {
                    if (!this.isCapturing || !this.isConnected) return;

                    if (!this.isPaused) {
                        this.generateSimulatedScreen();
                        this.updateFPS();
                    }

                    setTimeout(simulate, 100); // 10 FPS
                };
                simulate();
            }

            generateSimulatedScreen() {
                // ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌôîÎ©¥ ÏÉùÏÑ± (Ïä§ÌéôÌä∏Îüº Î∂ÑÏÑùÍ∏∞ ÌôîÎ©¥ Î™®ÏÇ¨)
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Í≤©Ïûê Í∑∏Î¶¨Í∏∞
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                // ÏàòÏßÅ Í≤©Ïûê
                for (let i = 0; i <= 10; i++) {
                    const x = (this.canvas.width * i) / 10;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // ÏàòÌèâ Í≤©Ïûê
                for (let i = 0; i <= 8; i++) {
                    const y = (this.canvas.height * i) / 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // ÏãúÎÆ¨Î†àÏù¥ÏÖò Ïä§ÌéôÌä∏Îüº Í≥°ÏÑ†
                this.ctx.strokeStyle = this.invertColors ? '#000' : '#0f0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                const time = Date.now() / 1000;
                for (let x = 0; x < this.canvas.width; x++) {
                    const freq = x / this.canvas.width;
                    const y = this.canvas.height * 0.8 - 
                        Math.sin(freq * Math.PI * 4 + time) * 30 -
                        Math.sin(freq * Math.PI * 8 + time * 2) * 15 -
                        Math.random() * 5;
                    
                    if (x === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥ ÌëúÏãú
                this.ctx.fillStyle = this.invertColors ? '#000' : '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`${this.deviceType.toUpperCase()} - ÏãúÎÆ¨Î†àÏù¥ÏÖò`, 10, 20);
                this.ctx.fillText('1MHz - 900MHz', 10, this.canvas.height - 30);
                this.ctx.fillText(`Ref: -10dBm`, 10, this.canvas.height - 15);

                // ÎßàÏª§
                const markerX = this.canvas.width / 2;
                const markerY = this.canvas.height * 0.5;
                this.ctx.strokeStyle = this.invertColors ? '#000' : '#ff0';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(markerX, 0);
                this.ctx.lineTo(markerX, this.canvas.height);
                this.ctx.stroke();

                // Î∞∞ÌÑ∞Î¶¨ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                this.elements.battery.textContent = '3.7V';
                this.elements.compression.textContent = 'Simulated';

                if (this.invertColors) {
                    this.applyColorInversion();
                }
            }

            parseScreenData(data) {
                // Ïã§Ï†ú Ïû•ÎπÑÏóêÏÑú Î∞õÏùÄ ÌôîÎ©¥ Îç∞Ïù¥ÌÑ∞ ÌååÏã±
                // RLE ÏïïÏ∂ï Ìï¥Ï†ú ÎòêÎäî RGB565 Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
                // Ïù¥ Î∂ÄÎ∂ÑÏùÄ Ïã§Ï†ú Ïû•ÎπÑÏùò ÏùëÎãµ ÌòïÏãùÏóê Îî∞Îùº Íµ¨ÌòÑ
                console.log('Received screen data:', data.length, 'bytes');
            }

            applyColorInversion() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];     // Red
                    data[i + 1] = 255 - data[i + 1]; // Green
                    data[i + 2] = 255 - data[i + 2]; // Blue
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }

            handleScreenClick(event) {
                if (!this.isConnected) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / (rect.width / this.zoom);
                const scaleY = this.canvas.height / (rect.height / this.zoom);
                
                const x = Math.floor((event.clientX - rect.left) * scaleX);
                const y = Math.floor((event.clientY - rect.top) * scaleY);

                console.log(`Touch at: ${x}, ${y}`);
                
                if (!this.simulationMode && this.serialPort) {
                    // Ïã§Ï†ú Ïû•ÎπÑÏóê ÌÑ∞Ïπò Ï¢åÌëú Ï†ÑÏÜ°
                    this.sendTouchCommand(x, y);
                } else {
                    // ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌÑ∞Ïπò Ìö®Í≥º
                    this.showTouchFeedback(x, y);
                }
            }

            async sendTouchCommand(x, y) {
                try {
                    const encoder = new TextEncoder();
                    const writer = this.serialPort.writable.getWriter();
                    await writer.write(encoder.encode(`touch ${x} ${y}\r\n`));
                    writer.releaseLock();
                } catch (error) {
                    console.error('ÌÑ∞Ïπò Î™ÖÎ†π Ï†ÑÏÜ° Ïã§Ìå®:', error);
                }
            }

            showTouchFeedback(x, y) {
                this.ctx.strokeStyle = '#f00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 10, 0, 2 * Math.PI);
                this.ctx.stroke();
                
                setTimeout(() => {
                    // ÌÑ∞Ïπò Ìö®Í≥º Ï†úÍ±∞Î•º ÏúÑÌï¥ ÌôîÎ©¥ Îã§Ïãú Í∑∏Î¶¨Í∏∞
                    if (this.simulationMode) {
                        this.generateSimulatedScreen();
                    }
                }, 200);
            }

            handleMouseMove(event) {
                // ÎßàÏö∞Ïä§ Ïª§ÏÑú ÏúÑÏπò ÌëúÏãú (ÏòµÏÖò)
            }

            pauseCapture() {
                this.isPaused = true;
                this.elements.pauseBtn.disabled = true;
                this.elements.resumeBtn.disabled = false;
            }

            resumeCapture() {
                this.isPaused = false;
                this.elements.pauseBtn.disabled = false;
                this.elements.resumeBtn.disabled = true;
            }

            zoomIn() {
                if (this.zoom < 4) {
                    this.zoom += 0.5;
                    this.updateScreenSize();
                }
            }

            zoomOut() {
                if (this.zoom > 1) {
                    this.zoom -= 0.5;
                    this.updateScreenSize();
                }
            }

            resetZoom() {
                this.zoom = 2;
                this.updateScreenSize();
            }

            fitToScreen() {
                // ÌôîÎ©¥ ÌÅ¨Í∏∞Ïóê ÎßûÏ∂∞ ÏûêÎèô Ï§å Ï°∞Ï†à
                const container = this.elements.deviceScreen.parentElement;
                const containerWidth = container.clientWidth - 100;
                const containerHeight = container.clientHeight - 100;
                
                const scaleX = containerWidth / this.canvas.width;
                const scaleY = containerHeight / this.canvas.height;
                
                this.zoom = Math.min(scaleX, scaleY, 4);
                this.updateScreenSize();
            }

            toggleInvert() {
                this.invertColors = !this.invertColors;
                this.elements.invertBtn.textContent = this.invertColors ? 'ÏÉâÏÉÅ Î≥µÏõê' : 'ÏÉâÏÉÅ Î∞òÏ†Ñ';
            }

            takeScreenshot() {
                this.saveScreenshot();
            }

            singleCapture() {
                if (this.isConnected && !this.simulationMode) {
                    // Îã®Ïùº Ï∫°Ï≤ò Î™ÖÎ†π
                    this.sendDeviceCommand('capture');
                }
            }

            toggleContinuousCapture() {
                if (this.isCapturing) {
                    this.isCapturing = false;
                    this.elements.continuousCaptureBtn.textContent = 'Ïó∞ÏÜç Ï∫°Ï≤ò ÏãúÏûë';
                } else {
                    this.isCapturing = true;
                    this.elements.continuousCaptureBtn.textContent = 'Ïó∞ÏÜç Ï∫°Ï≤ò Ï§ëÏßÄ';
                    if (this.simulationMode) {
                        this.startSimulation();
                    } else {
                        this.startRealCapture();
                    }
                }
            }

            logToTerminal(message) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
                
                // DOM ÏöîÏÜåÍ∞Ä ÏûàÎäîÏßÄ ÏïàÏ†ÑÌïòÍ≤å ÌôïÏù∏
                if (!this.elements || !this.elements.terminal) {
                    const terminalElement = document.getElementById('terminal');
                    if (terminalElement) {
                        if (!this.elements) this.elements = {};
                        this.elements.terminal = terminalElement;
                    } else {
                        // ÌÑ∞ÎØ∏ÎÑê ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏúºÎ©¥ ÏΩòÏÜîÏóêÎßå Ï∂úÎ†•
                        return;
                    }
                }
                
                try {
                    const line = document.createElement('div');
                    line.className = 'terminal-line';
                    line.textContent = `[${timestamp}] ${message}`;
                    this.elements.terminal.appendChild(line);
                    this.elements.terminal.scrollTop = this.elements.terminal.scrollHeight;
                    
                    // ÌÑ∞ÎØ∏ÎÑê ÎùºÏù∏ Ïàò Ï†úÌïú (ÏÑ±Îä•ÏùÑ ÏúÑÌï¥)
                    const lines = this.elements.terminal.children;
                    if (lines.length > 100) {
                        lines[0].remove();
                    }
                } catch (error) {
                    console.error('ÌÑ∞ÎØ∏ÎÑê Î°úÍ∑∏ Ïò§Î•ò:', error);
                }
            }

            async runDiagnostics() {
                this.logToTerminal('üîß ÏãúÏä§ÌÖú ÏßÑÎã® ÏãúÏûë...');
                
                // Î∏åÎùºÏö∞Ï†Ä Ï†ïÎ≥¥
                this.logToTerminal(`üåê Î∏åÎùºÏö∞Ï†Ä: ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
                this.logToTerminal(`üîí ÌîÑÎ°úÌÜ†ÏΩú: ${window.location.protocol}`);
                
                // WebSerial ÏßÄÏõê ÌôïÏù∏
                if ('serial' in navigator) {
                    this.logToTerminal('‚úÖ WebSerial API ÏßÄÏõêÎê®');
                    
                    // Permissions API ÌôïÏù∏
                    if ('permissions' in navigator) {
                        try {
                            const permission = await navigator.permissions.query({ name: 'serial' });
                            this.logToTerminal(`üîê Serial Í∂åÌïú ÏÉÅÌÉú: ${permission.state}`);
                        } catch (error) {
                            this.logToTerminal(`‚ö†Ô∏è  Í∂åÌïú ÌôïÏù∏ Ïã§Ìå®: ${error.message}`);
                        }
                    }
                } else {
                    this.logToTerminal('‚ùå WebSerial API ÎØ∏ÏßÄÏõê');
                    this.logToTerminal('üí° Ìï¥Í≤∞Î∞©Î≤ï: Chrome 89+ ÎòêÎäî Edge 89+ ÏÇ¨Ïö©');
                }
                
                // HTTPS ÌôïÏù∏
                if (window.location.protocol === 'https:') {
                    this.logToTerminal('‚úÖ HTTPS ÌôòÍ≤Ω (WebSerial ÏÇ¨Ïö© Í∞ÄÎä•)');
                } else {
                    this.logToTerminal('‚ùå HTTP ÌôòÍ≤Ω (WebSerial ÏÇ¨Ïö© Î∂àÍ∞Ä)');
                    this.logToTerminal('üí° Ìï¥Í≤∞Î∞©Î≤ï: https:// Î°ú Ï†ëÏÜçÌïòÍ±∞ÎÇò localhost ÏÇ¨Ïö©');
                }
                
                this.logToTerminal('‚úÖ ÏãúÏä§ÌÖú ÏßÑÎã® ÏôÑÎ£å');
            }

            async listAvailablePorts() {
                if (this.simulationMode) {
                    this.logToTerminal('‚ùå WebSerial ÎØ∏ÏßÄÏõêÏúºÎ°ú Ìè¨Ìä∏ ÌôïÏù∏ Î∂àÍ∞Ä');
                    return;
                }
                
                try {
                    this.logToTerminal('üîç ÏÇ¨Ïö©Í∞ÄÎä•Ìïú Ìè¨Ìä∏ Í≤ÄÏÉâ Ï§ë...');
                    const ports = await navigator.serial.getPorts();
                    
                    if (ports.length === 0) {
                        this.logToTerminal('üìã Í∂åÌïú Î∂ÄÏó¨Îêú Ìè¨Ìä∏ ÏóÜÏùå');
                        this.logToTerminal('üí° "Ïû•ÎπÑ Ïó∞Í≤∞" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ìè¨Ìä∏ Í∂åÌïú Î∂ÄÏó¨');
                    } else {
                        this.logToTerminal(`üìã Î∞úÍ≤¨Îêú Ìè¨Ìä∏: ${ports.length}Í∞ú`);
                        
                        for (let i = 0; i < ports.length; i++) {
                            const port = ports[i];
                            const info = port.getInfo();
                            this.logToTerminal(`  Ìè¨Ìä∏ ${i + 1}: VID=0x${info.usbVendorId?.toString(16) || 'unknown'}, PID=0x${info.usbProductId?.toString(16) || 'unknown'}`);
                            
                            if (info.usbVendorId === 0x0483 && info.usbProductId === 0x5740) {
                                this.logToTerminal('    ‚úÖ tinySA/NanoVNA Ìò∏Ìôò!');
                            }
                        }
                    }
                } catch (error) {
                    this.logToTerminal(`‚ùå Ìè¨Ìä∏ Í≤ÄÏÉâ Ïã§Ìå®: ${error.message}`);
                }
            }

            async testConnection() {
                if (this.simulationMode) {
                    this.logToTerminal('‚ùå WebSerial ÎØ∏ÏßÄÏõêÏúºÎ°ú Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Î∂àÍ∞Ä');
                    return;
                }
                
                this.logToTerminal('üß™ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏãúÏûë...');
                
                try {
                    // Ìè¨Ìä∏ ÏÑ†ÌÉù
                    this.logToTerminal('üìã ÌÖåÏä§Ìä∏Ïö© Ìè¨Ìä∏ ÏÑ†ÌÉù Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú...');
                    const testPort = await navigator.serial.requestPort({
                        filters: [{ usbVendorId: 0x0483, usbProductId: 0x5740 }]
                    });
                    
                    this.logToTerminal('‚úÖ Ìè¨Ìä∏ ÏÑ†ÌÉù ÏôÑÎ£å');
                    
                    // Ìè¨Ìä∏ Ïó¥Í∏∞
                    this.logToTerminal('üîó Ìè¨Ìä∏ Ïó¥Í∏∞ ÏãúÎèÑ...');
                    await testPort.open({
                        baudRate: 115200,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none'
                    });
                    
                    this.logToTerminal('‚úÖ Ìè¨Ìä∏ Ïó¥Í∏∞ ÏÑ±Í≥µ');
                    
                    // Í∞ÑÎã®Ìïú Î™ÖÎ†π ÌÖåÏä§Ìä∏
                    this.logToTerminal('üì§ ÌÖåÏä§Ìä∏ Î™ÖÎ†π Ï†ÑÏÜ° (info)...');
                    const encoder = new TextEncoder();
                    const decoder = new TextDecoder();
                    
                    const writer = testPort.writable.getWriter();
                    await writer.write(encoder.encode('info\r\n'));
                    writer.releaseLock();
                    
                    // ÏùëÎãµ ÏùΩÍ∏∞ (ÌÉÄÏûÑÏïÑÏõÉ Ìè¨Ìï®)
                    const reader = testPort.readable.getReader();
                    const timeout = setTimeout(() => reader.cancel(), 2000);
                    
                    try {
                        const { value } = await reader.read();
                        clearTimeout(timeout);
                        
                        if (value) {
                            const response = decoder.decode(value);
                            this.logToTerminal(`üì• Ïû•ÎπÑ ÏùëÎãµ: ${response.trim()}`);
                            this.logToTerminal('‚úÖ ÌÜµÏã† ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ!');
                        } else {
                            this.logToTerminal('‚ö†Ô∏è  ÏùëÎãµ ÏóÜÏùå (ÏùºÎ∂Ä Ïû•ÎπÑÏóêÏÑú Ï†ïÏÉÅ)');
                        }
                    } catch (readError) {
                        this.logToTerminal(`‚ö†Ô∏è  ÏùëÎãµ ÏùΩÍ∏∞ Ïã§Ìå®: ${readError.message}`);
                    }
                    
                    reader.releaseLock();
                    
                    // Ìè¨Ìä∏ Îã´Í∏∞
                    await testPort.close();
                    this.logToTerminal('üîí ÌÖåÏä§Ìä∏ Ìè¨Ìä∏ Îã´Í∏∞ ÏôÑÎ£å');
                    this.logToTerminal('üéâ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏôÑÎ£å!');
                    
                } catch (error) {
                    this.logToTerminal(`‚ùå Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ïã§Ìå®: ${error.name} - ${error.message}`);
                    
                    if (error.name === 'NotFoundError') {
                        this.logToTerminal('üí° Ìï¥Í≤∞Î∞©Î≤ï: USB ÏºÄÏù¥Î∏îÍ≥º Ïû•ÎπÑ Ïó∞Í≤∞ ÌôïÏù∏');
                    } else if (error.name === 'SecurityError') {
                        this.logToTerminal('üí° Ìï¥Í≤∞Î∞©Î≤ï: HTTPS ÌôòÍ≤ΩÏóêÏÑú Ï†ëÏÜç');
                    } else if (error.name === 'InvalidStateError') {
                        this.logToTerminal('üí° Ìï¥Í≤∞Î∞©Î≤ï: Îã§Î•∏ ÌîÑÎ°úÍ∑∏Îû®ÏóêÏÑú Ïû•ÎπÑ ÏÇ¨Ïö© Ï§ëÏùº Ïàò ÏûàÏùå');
                    }
                }
            }

            saveScreenshot() {
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `${this.deviceType}_${timestamp}.png`;
                
                this.canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.logToTerminal(`üì∏ Ïä§ÌÅ¨Î¶∞ÏÉ∑ Ï†ÄÏû•: ${filename}`);
                });
            }

            async sendDeviceCommand(command) {
                if (!this.simulationMode && this.serialPort) {
                    try {
                        const encoder = new TextEncoder();
                        const writer = this.serialPort.writable.getWriter();
                        await writer.write(encoder.encode(command + '\r\n'));
                        writer.releaseLock();
                    } catch (error) {
                        console.error('Î™ÖÎ†π Ï†ÑÏÜ° Ïã§Ìå®:', error);
                    }
                }
            }

            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    this.elements.fpsCounter.textContent = `FPS: ${this.fps}`;
                    this.elements.fpsValue.textContent = this.fps.toString();
                }
            }
        }

        // Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏãúÏûë
        document.addEventListener('DOMContentLoaded', () => {
            window.controller = new NanoVNARemoteController();
        });
    </script>
</body>
</html>
