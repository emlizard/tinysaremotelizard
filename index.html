<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NanoVNA/tinySA ë¦¬ëª¨íŠ¸ ë¯¸ëŸ¬ë§</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a3a);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .device-selector {
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }

        .screen-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .device-screen {
            background: #000;
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            position: relative;
            cursor: crosshair;
            transition: transform 0.3s ease;
        }

        .device-screen canvas {
            display: block;
            border-radius: 7px;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 1.2rem;
            border-radius: 7px;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .control-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            color: #64b5f6;
            margin-bottom: 1rem;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        button:hover {
            background: linear-gradient(45deg, #1976d2, #1565c0);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(25, 118, 210, 0.4);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .hotkeys {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.6;
        }

        .hotkeys h4 {
            color: #64b5f6;
            margin-bottom: 0.5rem;
        }

        .hotkey {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .capture-info {
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #ccc;
        }

        .device-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .value {
            color: #64b5f6;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                height: 200px;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ“¡ NanoVNA/tinySA ë¦¬ëª¨íŠ¸ ë¯¸ëŸ¬ë§</h1>
        <div class="controls">
            <select class="device-selector" id="deviceType">
                <option value="nanovna">NanoVNA-H</option>
                <option value="nanovna-h4">NanoVNA-H4</option>
                <option value="tinysa">tinySA</option>
                <option value="tinysa-ultra">tinySA Ultra</option>
                <option value="tinypfa">tinyPFA</option>
            </select>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="connectionStatus">ì—°ê²° ì•ˆë¨</span>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="screen-area">
            <div class="device-screen" id="deviceScreen">
                <canvas id="screenCanvas" width="320" height="240"></canvas>
                <div class="screen-overlay" id="screenOverlay">
                    <div>ğŸ”Œ ì¥ë¹„ë¥¼ ì—°ê²°í•˜ì„¸ìš”</div>
                    <div style="font-size: 0.9rem; margin-top: 1rem; opacity: 0.7;">
                        WebSerial ì§€ì› ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤ì œ ì¥ë¹„ ì—°ê²° ê°€ëŠ¥
                    </div>
                </div>
            </div>
            
            <div class="fps-counter" id="fpsCounter">FPS: 0</div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn" title="í™•ëŒ€ (+)">+</button>
                <button class="zoom-btn" id="zoomOut" title="ì¶•ì†Œ (-)">-</button>
                <button class="zoom-btn" id="screenshot" title="ìŠ¤í¬ë¦°ìƒ· (S)">ğŸ“·</button>
            </div>

            <div class="capture-info">
                í™”ë©´ì„ í´ë¦­í•˜ì—¬ ì¥ë¹„ ì¡°ì‘ | í‚¤ë³´ë“œ: +/- ì¤Œ, S ìŠ¤í¬ë¦°ìƒ·, ESC ì¢…ë£Œ
            </div>
        </div>

        <div class="control-panel">
            <div class="section">
                <h3>ğŸ”Œ ì¥ë¹„ ì—°ê²°</h3>
                <button id="connectBtn">ì¥ë¹„ ì—°ê²°</button>
                <button id="disconnectBtn" disabled>ì—°ê²° í•´ì œ</button>
                <button id="pauseBtn" disabled>í™”ë©´ ì¼ì‹œì •ì§€</button>
                <button id="resumeBtn" disabled>í™”ë©´ ì¬ê°œ</button>
            </div>

            <div class="device-info" id="deviceInfo" style="display: none;">
                <h4 style="color: #64b5f6; margin-bottom: 0.5rem;">ì¥ë¹„ ì •ë³´</h4>
                <div class="info-row">
                    <span>í•´ìƒë„:</span>
                    <span class="value" id="resolution">320Ã—240</span>
                </div>
                <div class="info-row">
                    <span>FPS:</span>
                    <span class="value" id="fpsValue">0</span>
                </div>
                <div class="info-row">
                    <span>ì••ì¶•:</span>
                    <span class="value" id="compression">RLE</span>
                </div>
                <div class="info-row">
                    <span>ë°°í„°ë¦¬:</span>
                    <span class="value" id="battery">-</span>
                </div>
            </div>

            <div class="section">
                <h3>âš™ï¸ í™”ë©´ ì„¤ì •</h3>
                <button id="invertBtn">ìƒ‰ìƒ ë°˜ì „</button>
                <button id="fitScreenBtn">í™”ë©´ ë§ì¶¤</button>
                <button id="resetZoomBtn">ì¤Œ ë¦¬ì…‹</button>
            </div>

            <div class="section">
                <h3>ğŸ“¸ ìº¡ì²˜</h3>
                <button id="singleCaptureBtn">ë‹¨ì¼ ìº¡ì²˜</button>
                <button id="continuousCaptureBtn">ì—°ì† ìº¡ì²˜ ì‹œì‘</button>
                <button id="saveScreenshotBtn">ìŠ¤í¬ë¦°ìƒ· ì €ì¥</button>
            </div>

            <div class="section">
                <h3>ğŸ”§ ì‹œìŠ¤í…œ ì§„ë‹¨</h3>
                <button id="diagnosisBtn">ì‹œìŠ¤í…œ í™˜ê²½ ì²´í¬</button>
                <button id="listPortsBtn">ì‚¬ìš©ê°€ëŠ¥ í¬íŠ¸ í™•ì¸</button>
                <button id="testConnectionBtn">ì—°ê²° í…ŒìŠ¤íŠ¸</button>
                <button id="httpsGuideBtn">HTTPS ì„¤ì • ê°€ì´ë“œ</button>
            </div>

            <div class="hotkeys">
                <h4>ğŸ® ë‹¨ì¶•í‚¤</h4>
                <div class="hotkey">
                    <span>í™•ëŒ€</span>
                    <span class="key">+</span>
                </div>
                <div class="hotkey">
                    <span>ì¶•ì†Œ</span>
                    <span class="key">-</span>
                </div>
                <div class="hotkey">
                    <span>ìŠ¤í¬ë¦°ìƒ·</span>
                    <span class="key">S</span>
                </div>
                <div class="hotkey">
                    <span>ì¢…ë£Œ</span>
                    <span class="key">ESC</span>
                </div>
                <div class="hotkey">
                    <span>ì¼ì‹œì •ì§€</span>
                    <span class="key">SPACE</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NanoVNARemoteController {
            constructor() {
                this.isConnected = false;
                this.serialPort = null;
                this.deviceType = 'nanovna';
                this.zoom = 2;
                this.isCapturing = false;
                this.isPaused = false;
                this.invertColors = false;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.screenData = null;
                this.simulationMode = !('serial' in navigator);
                this.availableDevices = [];
                
                // DOM ìš”ì†Œë“¤ì´ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°
                this.initializeWhenReady();
            }

            async initializeWhenReady() {
                // DOM ìš”ì†Œë“¤ì´ ëª¨ë‘ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
                let retries = 0;
                while (retries < 10) {
                    try {
                        this.canvas = document.getElementById('screenCanvas');
                        if (!this.canvas) {
                            retries++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                            continue;
                        }
                        
                        this.ctx = this.canvas.getContext('2d');
                        this.initializeElements();
                        
                        // ëª¨ë“  ìš”ì†Œê°€ ì •ìƒì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
                        if (!this.elements.terminal) {
                            console.warn('í„°ë¯¸ë„ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì½˜ì†”ì—ë§Œ ë¡œê·¸ ì¶œë ¥ë©ë‹ˆë‹¤.');
                        }
                        
                        this.setupEventListeners();
                        this.setupKeyboardShortcuts();
                        this.updateDeviceResolution();
                        this.checkWebSerialSupport();
                        
                        console.log('âœ… ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì™„ë£Œ');
                        
                        if (this.simulationMode) {
                            this.startSimulation();
                        } else {
                            this.startDeviceMonitoring();
                        }
                        
                        break;
                    } catch (error) {
                        console.error('ì´ˆê¸°í™” ì‹œë„ ì‹¤íŒ¨:', error);
                        retries++;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                if (retries >= 10) {
                    console.error('ì´ˆê¸°í™” ì‹¤íŒ¨: DOM ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
            }

            async startDeviceMonitoring() {
                // í˜ì´ì§€ ë¡œë“œ ì‹œ ì—°ê²°ëœ ì¥ë¹„ í™•ì¸
                await this.checkAvailableDevices();
                
                // USB ì¥ë¹„ ì—°ê²°/í•´ì œ ê°ì§€
                if ('serial' in navigator) {
                    navigator.serial.addEventListener('connect', (event) => {
                        console.log('ì¥ë¹„ ì—°ê²°ë¨:', event.port);
                        this.checkAvailableDevices();
                    });
                    
                    navigator.serial.addEventListener('disconnect', (event) => {
                        console.log('ì¥ë¹„ ì—°ê²° í•´ì œë¨:', event.port);
                        this.checkAvailableDevices();
                        if (event.port === this.serialPort) {
                            this.disconnect();
                        }
                    });
                }
            }

            async checkAvailableDevices() {
                if (this.simulationMode) return;
                
                try {
                    const ports = await navigator.serial.getPorts();
                    this.availableDevices = [];
                    
                    for (const port of ports) {
                        const info = port.getInfo();
                        if (info.usbVendorId === 0x0483 && info.usbProductId === 0x5740) {
                            this.availableDevices.push({
                                port: port,
                                vendorId: info.usbVendorId,
                                productId: info.usbProductId
                            });
                        }
                    }
                    
                    this.updateDeviceStatus();
                } catch (error) {
                    console.error('ì¥ë¹„ í™•ì¸ ì‹¤íŒ¨:', error);
                }
            }

            updateDeviceStatus() {
                const hasDevice = this.availableDevices.length > 0;
                
                if (hasDevice && !this.isConnected) {
                    this.elements.connectionStatus.textContent = `${this.availableDevices.length}ê°œ ì¥ë¹„ ê°ì§€ë¨`;
                    this.elements.connectBtn.textContent = 'ìë™ ì—°ê²°';
                } else if (!hasDevice && !this.isConnected) {
                    this.elements.connectionStatus.textContent = 'ì¥ë¹„ ì—†ìŒ';
                    this.elements.connectBtn.textContent = 'ì¥ë¹„ ì—°ê²°';
                }
            }

            initializeElements() {
                const elementIds = [
                    'deviceType', 'statusDot', 'connectionStatus', 'deviceScreen', 'screenOverlay',
                    'fpsCounter', 'deviceInfo', 'resolution', 'fpsValue', 'compression', 'battery',
                    'connectBtn', 'disconnectBtn', 'pauseBtn', 'resumeBtn', 'zoomIn', 'zoomOut',
                    'screenshot', 'invertBtn', 'fitScreenBtn', 'resetZoomBtn', 'singleCaptureBtn',
                    'continuousCaptureBtn', 'saveScreenshotBtn', 'diagnosisBtn', 'listPortsBtn',
                    'testConnectionBtn', 'terminal'
                ];
                
                this.elements = {};
                const missingElements = [];
                
                elementIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        this.elements[id] = element;
                    } else {
                        missingElements.push(id);
                        console.warn(`ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${id}`);
                    }
                });
                
                if (missingElements.length > 0) {
                    console.warn('ëˆ„ë½ëœ ìš”ì†Œë“¤:', missingElements);
                }
                
                console.log(`ì´ˆê¸°í™”ëœ ìš”ì†Œ: ${Object.keys(this.elements).length}/${elementIds.length}`);
            }

            setupEventListeners() {
                // ì•ˆì „í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ í•¨ìˆ˜
                const addSafeListener = (elementId, event, handler) => {
                    const element = this.elements[elementId];
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ ì‹¤íŒ¨: ${elementId} ìš”ì†Œê°€ ì—†ìŠµë‹ˆë‹¤`);
                    }
                };

                addSafeListener('deviceType', 'change', (e) => {
                    this.deviceType = e.target.value;
                    this.updateDeviceResolution();
                });

                addSafeListener('connectBtn', 'click', () => this.connect());
                addSafeListener('disconnectBtn', 'click', () => this.disconnect());
                addSafeListener('pauseBtn', 'click', () => this.pauseCapture());
                addSafeListener('resumeBtn', 'click', () => this.resumeCapture());

                addSafeListener('zoomIn', 'click', () => this.zoomIn());
                addSafeListener('zoomOut', 'click', () => this.zoomOut());
                addSafeListener('screenshot', 'click', () => this.takeScreenshot());

                addSafeListener('invertBtn', 'click', () => this.toggleInvert());
                addSafeListener('fitScreenBtn', 'click', () => this.fitToScreen());
                addSafeListener('resetZoomBtn', 'click', () => this.resetZoom());

                addSafeListener('singleCaptureBtn', 'click', () => this.singleCapture());
                addSafeListener('continuousCaptureBtn', 'click', () => this.toggleContinuousCapture());
                addSafeListener('saveScreenshotBtn', 'click', () => this.saveScreenshot());

                // ì§„ë‹¨ ê¸°ëŠ¥
                addSafeListener('diagnosisBtn', 'click', () => this.runDiagnostics());
                addSafeListener('listPortsBtn', 'click', () => this.listAvailablePorts());
                addSafeListener('testConnectionBtn', 'click', () => this.testConnection());
                addSafeListener('httpsGuideBtn', 'click', () => this.showHttpsGuide());

                // í™”ë©´ í´ë¦­ìœ¼ë¡œ ì¥ë¹„ í„°ì¹˜ ì‹œë®¬ë ˆì´ì…˜
                if (this.canvas) {
                    this.canvas.addEventListener('click', (e) => this.handleScreenClick(e));
                    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case '+':
                        case '=':
                            e.preventDefault();
                            this.zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            this.zoomOut();
                            break;
                        case 's':
                        case 'S':
                            e.preventDefault();
                            this.takeScreenshot();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.disconnect();
                            break;
                        case ' ':
                            e.preventDefault();
                            if (this.isPaused) {
                                this.resumeCapture();
                            } else {
                                this.pauseCapture();
                            }
                            break;
                    }
                });
            }

            updateDeviceResolution() {
                const deviceConfig = this.getDeviceConfig();
                
                this.canvas.width = deviceConfig.width;
                this.canvas.height = deviceConfig.height;
                this.elements.resolution.textContent = `${deviceConfig.width}Ã—${deviceConfig.height}`;
                
                // í—¤ë”ì— ì„ íƒëœ ì¥ë¹„ëª… í‘œì‹œ
                const headerTitle = document.querySelector('.header h1');
                headerTitle.textContent = `ğŸ“¡ ${deviceConfig.name} ë¦¬ëª¨íŠ¸ ë¯¸ëŸ¬ë§`;
                
                this.updateScreenSize();
                console.log(`ì¥ë¹„ ë³€ê²½: ${deviceConfig.name} (${deviceConfig.width}Ã—${deviceConfig.height})`);
            }

            updateScreenSize() {
                const scale = this.zoom;
                this.elements.deviceScreen.style.transform = `scale(${scale})`;
            }

            getDeviceConfig() {
                const configs = {
                    'nanovna': {
                        name: 'NanoVNA-H',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    },
                    'nanovna-h4': {
                        name: 'NanoVNA-H4',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320
                    },
                    'tinysa': {
                        name: 'tinySA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    },
                    'tinysa-ultra': {
                        name: 'tinySA Ultra',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320
                    },
                    'tinypfa': {
                        name: 'tinyPFA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240
                    }
                };
                return configs[this.deviceType];
            }

            async autoDetectDevice() {
                if (this.simulationMode) return null;
                
                try {
                    // ì´ë¯¸ ê¶Œí•œì´ ë¶€ì—¬ëœ í¬íŠ¸ë“¤ í™•ì¸
                    const ports = await navigator.serial.getPorts();
                    
                    for (const port of ports) {
                        const info = port.getInfo();
                        const deviceConfig = this.getDeviceConfig();
                        
                        // VID/PID ë§¤ì¹­ í™•ì¸
                        if (info.usbVendorId === deviceConfig.vendorId && 
                            info.usbProductId === deviceConfig.productId) {
                            console.log(`ì¥ë¹„ ìë™ ê°ì§€ë¨: VID=${info.usbVendorId.toString(16)}, PID=${info.usbProductId.toString(16)}`);
                            return port;
                        }
                    }
                    
                    console.log('ê¸°ì¡´ì— ì—°ê²°ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤. ìˆ˜ë™ ì„ íƒì´ í•„ìš”í•©ë‹ˆë‹¤.');
                    return null;
                } catch (error) {
                    console.error('ìë™ ê°ì§€ ì‹¤íŒ¨:', error);
                    return null;
                }
            }

            async connect() {
                this.elements.connectBtn.disabled = true;
                this.elements.connectionStatus.textContent = 'ì¥ë¹„ ê°ì§€ ì¤‘...';
                
                const deviceConfig = this.getDeviceConfig();

                if (!this.simulationMode) {
                    try {
                        // 1ë‹¨ê³„: ìë™ ì¥ë¹„ ê°ì§€ ì‹œë„
                        let detectedPort = await this.autoDetectDevice();
                        
                        if (detectedPort) {
                            // ìë™ ê°ì§€ëœ ì¥ë¹„ë¡œ ì—°ê²°
                            this.serialPort = detectedPort;
                            this.elements.connectionStatus.textContent = 'ìë™ ê°ì§€ëœ ì¥ë¹„ì— ì—°ê²° ì¤‘...';
                        } else {
                            // 2ë‹¨ê³„: ìˆ˜ë™ ì¥ë¹„ ì„ íƒ
                            this.elements.connectionStatus.textContent = 'ì¥ë¹„ë¥¼ ì„ íƒí•˜ì„¸ìš”...';
                            this.serialPort = await navigator.serial.requestPort({
                                filters: [{ 
                                    usbVendorId: deviceConfig.vendorId, 
                                    usbProductId: deviceConfig.productId 
                                }]
                            });
                            this.elements.connectionStatus.textContent = 'ì„ íƒëœ ì¥ë¹„ì— ì—°ê²° ì¤‘...';
                        }

                        // í¬íŠ¸ ì—´ê¸°
                        await this.serialPort.open({
                            baudRate: deviceConfig.baudRate,
                            dataBits: 8,
                            stopBits: 1,
                            parity: 'none'
                        });

                        // ì¥ë¹„ íƒ€ì… í™•ì¸
                        await this.verifyDeviceType();
                        
                        this.isConnected = true;
                        this.startRealCapture();
                    } catch (error) {
                        console.error('ì—°ê²° ì‹¤íŒ¨:', error);
                        this.elements.connectionStatus.textContent = `ì—°ê²° ì‹¤íŒ¨: ${error.message}`;
                        this.elements.connectBtn.disabled = false;
                        return;
                    }
                } else {
                    // ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ
                    setTimeout(() => {
                        this.isConnected = true;
                        this.updateConnectionStatus();
                        this.startSimulation();
                    }, 1000);
                }

                this.updateConnectionStatus();
            }

            async verifyDeviceType() {
                if (!this.serialPort) return;
                
                try {
                    const encoder = new TextEncoder();
                    const decoder = new TextDecoder();
                    
                    // ì¥ë¹„ ì •ë³´ ìš”ì²­
                    const writer = this.serialPort.writable.getWriter();
                    await writer.write(encoder.encode('info\r\n'));
                    writer.releaseLock();

                    // ì‘ë‹µ ì½ê¸°
                    const reader = this.serialPort.readable.getReader();
                    const { value } = await reader.read();
                    const response = decoder.decode(value);
                    reader.releaseLock();

                    console.log('ì¥ë¹„ ì •ë³´:', response);
                    
                    // ì‘ë‹µì—ì„œ ì¥ë¹„ íƒ€ì… í™•ì¸
                    if (response.includes('tinySA') && this.deviceType.includes('nanovna')) {
                        throw new Error('ì„ íƒëœ ì¥ë¹„ íƒ€ì…ê³¼ ì‹¤ì œ ì¥ë¹„ê°€ ë‹¤ë¦…ë‹ˆë‹¤. tinySAê°€ ì—°ê²°ë¨');
                    } else if (response.includes('NanoVNA') && this.deviceType.includes('tinysa')) {
                        throw new Error('ì„ íƒëœ ì¥ë¹„ íƒ€ì…ê³¼ ì‹¤ì œ ì¥ë¹„ê°€ ë‹¤ë¦…ë‹ˆë‹¤. NanoVNAê°€ ì—°ê²°ë¨');
                    }
                    
                } catch (error) {
                    console.warn('ì¥ë¹„ íƒ€ì… í™•ì¸ ì‹¤íŒ¨:', error);
                    // í™•ì¸ ì‹¤íŒ¨ì‹œì—ë„ ì—°ê²°ì€ ì§„í–‰ (ì¼ë¶€ ì¥ë¹„ì—ì„œ info ëª…ë ¹ ë¯¸ì§€ì›)
                }
            }

            async disconnect() {
                if (this.serialPort && !this.simulationMode) {
                    await this.serialPort.close();
                }

                this.isConnected = false;
                this.isCapturing = false;
                this.serialPort = null;
                this.updateConnectionStatus();
            }

            updateConnectionStatus() {
                if (this.isConnected) {
                    this.elements.statusDot.classList.add('connected');
                    this.elements.connectionStatus.textContent = 'ì—°ê²°ë¨';
                    this.elements.screenOverlay.style.display = 'none';
                    this.elements.deviceInfo.style.display = 'block';
                    this.elements.connectBtn.disabled = true;
                    this.elements.disconnectBtn.disabled = false;
                    this.elements.pauseBtn.disabled = false;
                    this.elements.resumeBtn.disabled = false;
                } else {
                    this.elements.statusDot.classList.remove('connected');
                    this.elements.connectionStatus.textContent = 'ì—°ê²° ì•ˆë¨';
                    this.elements.screenOverlay.style.display = 'flex';
                    this.elements.deviceInfo.style.display = 'none';
                    this.elements.connectBtn.disabled = false;
                    this.elements.disconnectBtn.disabled = true;
                    this.elements.pauseBtn.disabled = true;
                    this.elements.resumeBtn.disabled = true;
                }
            }

            async startRealCapture() {
                // ì•ˆì „ì„± ì²´í¬
                if (!this.serialPort) {
                    this.logToTerminal('âŒ ì‹œë¦¬ì–¼ í¬íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.');
                    this.startSimulation();
                    return;
                }
                
                if (!this.isConnected) {
                    this.logToTerminal('âŒ ì¥ë¹„ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return;
                }

                if (this.simulationMode) {
                    this.logToTerminal('âš ï¸  ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ ìº¡ì²˜ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
                    this.startSimulation();
                    return;
                }

                this.isCapturing = true;
                this.logToTerminal('ğŸ¬ ì‹¤ì‹œê°„ í™”ë©´ ìº¡ì²˜ ì‹œì‘...');
                
                const encoder = new TextEncoder();
                const decoder = new TextDecoder();

                while (this.isCapturing && this.isConnected && this.serialPort) {
                    try {
                        if (!this.isPaused) {
                            this.logToTerminal('ğŸ“¸ í™”ë©´ ìº¡ì²˜ ì¤‘...');
                            
                            // serialPort ìƒíƒœ ì¬í™•ì¸
                            if (!this.serialPort || !this.serialPort.writable) {
                                this.logToTerminal('âŒ ì‹œë¦¬ì–¼ í¬íŠ¸ê°€ ë‹«í˜€ìˆìŠµë‹ˆë‹¤. ìº¡ì²˜ë¥¼ ì¤‘ë‹¨í•©ë‹ˆë‹¤.');
                                break;
                            }
                            
                            // í™”ë©´ ì¼ì‹œì •ì§€ ëª…ë ¹
                            const writer1 = this.serialPort.writable.getWriter();
                            await writer1.write(encoder.encode('pause\r\n'));
                            writer1.releaseLock();
                            await this.delay(100);
                            
                            // í™”ë©´ ìº¡ì²˜ ëª…ë ¹ (RLE ì••ì¶• ì‹œë„)
                            if (!this.serialPort || !this.serialPort.writable) {
                                this.logToTerminal('âŒ í¬íŠ¸ê°€ ë‹«í˜”ìŠµë‹ˆë‹¤.');
                                break;
                            }
                            
                            const writer2 = this.serialPort.writable.getWriter();
                            await writer2.write(encoder.encode('capture rle\r\n'));
                            writer2.releaseLock();
                            
                            // ì‘ë‹µ ì½ê¸°
                            if (!this.serialPort || !this.serialPort.readable) {
                                this.logToTerminal('âŒ í¬íŠ¸ ì½ê¸° ë¶ˆê°€ëŠ¥');
                                break;
                            }
                            
                            const reader = this.serialPort.readable.getReader();
                            const timeout = setTimeout(() => {
                                if (reader) reader.cancel();
                            }, 3000);
                            
                            try {
                                const { value } = await reader.read();
                                clearTimeout(timeout);
                                
                                if (value && value.length > 0) {
                                    this.logToTerminal(`ğŸ“¥ í™”ë©´ ë°ì´í„° ìˆ˜ì‹ : ${value.length} bytes`);
                                    await this.parseScreenData(value);
                                } else {
                                    this.logToTerminal('âš ï¸  í™”ë©´ ë°ì´í„° ì—†ìŒ - ì¼ë°˜ ìº¡ì²˜ ì‹œë„');
                                    
                                    // RLE ì‹¤íŒ¨ì‹œ ì¼ë°˜ ìº¡ì²˜ ì‹œë„
                                    if (this.serialPort && this.serialPort.writable) {
                                        const writer3 = this.serialPort.writable.getWriter();
                                        await writer3.write(encoder.encode('capture\r\n'));
                                        writer3.releaseLock();
                                        
                                        const { value: normalData } = await reader.read();
                                        if (normalData && normalData.length > 0) {
                                            this.logToTerminal(`ğŸ“¥ ì¼ë°˜ í™”ë©´ ë°ì´í„° ìˆ˜ì‹ : ${normalData.length} bytes`);
                                            await this.parseScreenData(normalData);
                                        }
                                    }
                                }
                            } catch (readError) {
                                this.logToTerminal(`âŒ ë°ì´í„° ì½ê¸° ì‹¤íŒ¨: ${readError.message}`);
                            }
                            
                            if (reader) reader.releaseLock();
                            
                            // í™”ë©´ ì—…ë°ì´íŠ¸ ì¬ê°œ
                            if (this.serialPort && this.serialPort.writable) {
                                const writer4 = this.serialPort.writable.getWriter();
                                await writer4.write(encoder.encode('resume\r\n'));
                                writer4.releaseLock();
                            }
                        }

                        this.updateFPS();
                        await this.delay(200); // 5 FPSë¡œ ì œí•œ
                        
                    } catch (error) {
                        this.logToTerminal(`âŒ ìº¡ì²˜ ì˜¤ë¥˜: ${error.message}`);
                        
                        // ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒì‹œ ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ì „í™˜
                        if (error.message.includes('null') || error.message.includes('undefined')) {
                            this.logToTerminal('ğŸ”„ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤...');
                            this.simulationMode = true;
                            this.serialPort = null;
                            this.startSimulation();
                            break;
                        }
                        
                        await this.delay(1000); // ì˜¤ë¥˜ì‹œ 1ì´ˆ ëŒ€ê¸°
                    }
                }
                
                this.logToTerminal('ğŸ›‘ ì‹¤ì œ í™”ë©´ ìº¡ì²˜ ì¤‘ì§€ë¨');
            }

            async parseScreenData(data) {
                try {
                    // ë°ì´í„°ê°€ í…ìŠ¤íŠ¸ì¸ì§€ ë°”ì´ë„ˆë¦¬ì¸ì§€ í™•ì¸
                    const decoder = new TextDecoder();
                    const textData = decoder.decode(data);
                    
                    this.logToTerminal(`ğŸ” ë°ì´í„° ë¶„ì„: ${textData.slice(0, 50)}...`);
                    
                    // RLE í—¤ë” í™•ì¸
                    if (data[0] === 0x52 && data[1] === 0x4C && data[2] === 0x45) { // "RLE"
                        this.logToTerminal('ğŸ“¦ RLE ì••ì¶• ë°ì´í„° ê°ì§€');
                        await this.parseRLEData(data.slice(3));
                    } else if (data.length >= 320 * 240 * 2) { // RGB565 ì¶”ì •
                        this.logToTerminal('ğŸ–¼ï¸  RGB565 ë°ì´í„° ê°ì§€');
                        await this.parseRGB565Data(data);
                    } else {
                        this.logToTerminal('âš ï¸  ì•Œ ìˆ˜ ì—†ëŠ” ë°ì´í„° í˜•ì‹ - ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ì „í™˜');
                        this.generateSimulatedScreen();
                    }
                } catch (error) {
                    this.logToTerminal(`âŒ í™”ë©´ ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨: ${error.message}`);
                    this.generateSimulatedScreen(); // íŒŒì‹± ì‹¤íŒ¨ì‹œ ì‹œë®¬ë ˆì´ì…˜ í‘œì‹œ
                }
            }

            async parseRLEData(rleData) {
                try {
                    this.logToTerminal('ğŸ”“ RLE ë°ì´í„° ì••ì¶• í•´ì œ ì¤‘...');
                    
                    const deviceConfig = this.getDeviceConfig();
                    const width = deviceConfig.width;
                    const height = deviceConfig.height;
                    
                    // RLE ì••ì¶• í•´ì œ (ê°„ë‹¨í•œ êµ¬í˜„)
                    const pixels = new Uint8Array(width * height * 4); // RGBA
                    let pixelIndex = 0;
                    let dataIndex = 0;
                    
                    while (dataIndex < rleData.length && pixelIndex < pixels.length) {
                        const count = rleData[dataIndex++];
                        const r = rleData[dataIndex++] || 0;
                        const g = rleData[dataIndex++] || 0;
                        const b = rleData[dataIndex++] || 0;
                        
                        for (let i = 0; i < count && pixelIndex < pixels.length; i++) {
                            pixels[pixelIndex++] = r;
                            pixels[pixelIndex++] = g;
                            pixels[pixelIndex++] = b;
                            pixels[pixelIndex++] = 255; // Alpha
                        }
                    }
                    
                    // Canvasì— ê·¸ë¦¬ê¸°
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
                    this.ctx.putImageData(imageData, 0, 0);
                    
                    this.logToTerminal('âœ… RLE í™”ë©´ ë°ì´í„° í‘œì‹œ ì™„ë£Œ');
                } catch (error) {
                    this.logToTerminal(`âŒ RLE íŒŒì‹± ì‹¤íŒ¨: ${error.message}`);
                    this.generateSimulatedScreen();
                }
            }

            async parseRGB565Data(rgb565Data) {
                try {
                    this.logToTerminal('ğŸ¨ RGB565 ë°ì´í„° ë³€í™˜ ì¤‘...');
                    
                    const deviceConfig = this.getDeviceConfig();
                    const width = deviceConfig.width;
                    const height = deviceConfig.height;
                    
                    const pixels = new Uint8Array(width * height * 4); // RGBA
                    
                    for (let i = 0; i < width * height * 2; i += 2) {
                        const rgb565 = (rgb565Data[i] << 8) | rgb565Data[i + 1];
                        const pixelIndex = (i / 2) * 4;
                        
                        // RGB565ë¥¼ RGB888ë¡œ ë³€í™˜
                        const r = ((rgb565 >> 11) & 0x1F) << 3;
                        const g = ((rgb565 >> 5) & 0x3F) << 2;
                        const b = (rgb565 & 0x1F) << 3;
                        
                        pixels[pixelIndex] = r;
                        pixels[pixelIndex + 1] = g;
                        pixels[pixelIndex + 2] = b;
                        pixels[pixelIndex + 3] = 255; // Alpha
                    }
                    
                    // Canvasì— ê·¸ë¦¬ê¸°
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
                    this.ctx.putImageData(imageData, 0, 0);
                    
                    this.logToTerminal('âœ… RGB565 í™”ë©´ ë°ì´í„° í‘œì‹œ ì™„ë£Œ');
                } catch (error) {
                    this.logToTerminal(`âŒ RGB565 íŒŒì‹± ì‹¤íŒ¨: ${error.message}`);
                    this.generateSimulatedScreen();
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            startSimulation() {
                if (!this.isConnected) return;

                this.isCapturing = true;
                const simulate = () => {
                    if (!this.isCapturing || !this.isConnected) return;

                    if (!this.isPaused) {
                        this.generateSimulatedScreen();
                        this.updateFPS();
                    }

                    setTimeout(simulate, 100); // 10 FPS
                };
                simulate();
            }

            generateSimulatedScreen() {
                // ì‹œë®¬ë ˆì´ì…˜ í™”ë©´ ìƒì„± (ìŠ¤í™íŠ¸ëŸ¼ ë¶„ì„ê¸° í™”ë©´ ëª¨ì‚¬)
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ê²©ì ê·¸ë¦¬ê¸°
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                // ìˆ˜ì§ ê²©ì
                for (let i = 0; i <= 10; i++) {
                    const x = (this.canvas.width * i) / 10;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // ìˆ˜í‰ ê²©ì
                for (let i = 0; i <= 8; i++) {
                    const y = (this.canvas.height * i) / 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í™íŠ¸ëŸ¼ ê³¡ì„ 
                this.ctx.strokeStyle = this.invertColors ? '#000' : '#0f0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                const time = Date.now() / 1000;
                for (let x = 0; x < this.canvas.width; x++) {
                    const freq = x / this.canvas.width;
                    const y = this.canvas.height * 0.8 - 
                        Math.sin(freq * Math.PI * 4 + time) * 30 -
                        Math.sin(freq * Math.PI * 8 + time * 2) * 15 -
                        Math.random() * 5;
                    
                    if (x === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // í…ìŠ¤íŠ¸ ì •ë³´ í‘œì‹œ
                this.ctx.fillStyle = this.invertColors ? '#000' : '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`${this.deviceType.toUpperCase()} - ì‹œë®¬ë ˆì´ì…˜`, 10, 20);
                this.ctx.fillText('1MHz - 900MHz', 10, this.canvas.height - 30);
                this.ctx.fillText(`Ref: -10dBm`, 10, this.canvas.height - 15);

                // ë§ˆì»¤
                const markerX = this.canvas.width / 2;
                const markerY = this.canvas.height * 0.5;
                this.ctx.strokeStyle = this.invertColors ? '#000' : '#ff0';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(markerX, 0);
                this.ctx.lineTo(markerX, this.canvas.height);
                this.ctx.stroke();

                // ë°°í„°ë¦¬ ì •ë³´ ì—…ë°ì´íŠ¸
                this.elements.battery.textContent = '3.7V';
                this.elements.compression.textContent = 'Simulated';

                if (this.invertColors) {
                    this.applyColorInversion();
                }
            }

            parseScreenData(data) {
                // ì‹¤ì œ ì¥ë¹„ì—ì„œ ë°›ì€ í™”ë©´ ë°ì´í„° íŒŒì‹±
                // RLE ì••ì¶• í•´ì œ ë˜ëŠ” RGB565 ë°ì´í„° ì²˜ë¦¬
                // ì´ ë¶€ë¶„ì€ ì‹¤ì œ ì¥ë¹„ì˜ ì‘ë‹µ í˜•ì‹ì— ë”°ë¼ êµ¬í˜„
                console.log('Received screen data:', data.length, 'bytes');
            }

            applyColorInversion() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];     // Red
                    data[i + 1] = 255 - data[i + 1]; // Green
                    data[i + 2] = 255 - data[i + 2]; // Blue
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }

            handleScreenClick(event) {
                if (!this.isConnected) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / (rect.width / this.zoom);
                const scaleY = this.canvas.height / (rect.height / this.zoom);
                
                const x = Math.floor((event.clientX - rect.left) * scaleX);
                const y = Math.floor((event.clientY - rect.top) * scaleY);

                console.log(`Touch at: ${x}, ${y}`);
                
                if (!this.simulationMode && this.serialPort) {
                    // ì‹¤ì œ ì¥ë¹„ì— í„°ì¹˜ ì¢Œí‘œ ì „ì†¡
                    this.sendTouchCommand(x, y);
                } else {
                    // ì‹œë®¬ë ˆì´ì…˜ í„°ì¹˜ íš¨ê³¼
                    this.showTouchFeedback(x, y);
                }
            }

            async sendTouchCommand(x, y) {
                try {
                    const encoder = new TextEncoder();
                    const writer = this.serialPort.writable.getWriter();
                    await writer.write(encoder.encode(`touch ${x} ${y}\r\n`));
                    writer.releaseLock();
                } catch (error) {
                    console.error('í„°ì¹˜ ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨:', error);
                }
            }

            showTouchFeedback(x, y) {
                this.ctx.strokeStyle = '#f00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 10, 0, 2 * Math.PI);
                this.ctx.stroke();
                
                setTimeout(() => {
                    // í„°ì¹˜ íš¨ê³¼ ì œê±°ë¥¼ ìœ„í•´ í™”ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    if (this.simulationMode) {
                        this.generateSimulatedScreen();
                    }
                }, 200);
            }

            handleMouseMove(event) {
                // ë§ˆìš°ìŠ¤ ì»¤ì„œ ìœ„ì¹˜ í‘œì‹œ (ì˜µì…˜)
            }

            pauseCapture() {
                this.isPaused = true;
                this.elements.pauseBtn.disabled = true;
                this.elements.resumeBtn.disabled = false;
            }

            resumeCapture() {
                this.isPaused = false;
                this.elements.pauseBtn.disabled = false;
                this.elements.resumeBtn.disabled = true;
            }

            zoomIn() {
                if (this.zoom < 4) {
                    this.zoom += 0.5;
                    this.updateScreenSize();
                }
            }

            zoomOut() {
                if (this.zoom > 1) {
                    this.zoom -= 0.5;
                    this.updateScreenSize();
                }
            }

            resetZoom() {
                this.zoom = 2;
                this.updateScreenSize();
            }

            fitToScreen() {
                // í™”ë©´ í¬ê¸°ì— ë§ì¶° ìë™ ì¤Œ ì¡°ì ˆ
                const container = this.elements.deviceScreen.parentElement;
                const containerWidth = container.clientWidth - 100;
                const containerHeight = container.clientHeight - 100;
                
                const scaleX = containerWidth / this.canvas.width;
                const scaleY = containerHeight / this.canvas.height;
                
                this.zoom = Math.min(scaleX, scaleY, 4);
                this.updateScreenSize();
            }

            toggleInvert() {
                this.invertColors = !this.invertColors;
                this.elements.invertBtn.textContent = this.invertColors ? 'ìƒ‰ìƒ ë³µì›' : 'ìƒ‰ìƒ ë°˜ì „';
            }

            takeScreenshot() {
                this.saveScreenshot();
            }

            singleCapture() {
                if (this.isConnected && !this.simulationMode) {
                    // ë‹¨ì¼ ìº¡ì²˜ ëª…ë ¹
                    this.sendDeviceCommand('capture');
                }
            }

            toggleContinuousCapture() {
                if (this.isCapturing) {
                    this.isCapturing = false;
                    this.elements.continuousCaptureBtn.textContent = 'ì—°ì† ìº¡ì²˜ ì‹œì‘';
                } else {
                    this.isCapturing = true;
                    this.elements.continuousCaptureBtn.textContent = 'ì—°ì† ìº¡ì²˜ ì¤‘ì§€';
                    if (this.simulationMode) {
                        this.startSimulation();
                    } else {
                        this.startRealCapture();
                    }
                }
            }

            logToTerminal(message) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
                
                // DOM ìš”ì†Œê°€ ìˆëŠ”ì§€ ì•ˆì „í•˜ê²Œ í™•ì¸
                if (!this.elements || !this.elements.terminal) {
                    const terminalElement = document.getElementById('terminal');
                    if (terminalElement) {
                        if (!this.elements) this.elements = {};
                        this.elements.terminal = terminalElement;
                    } else {
                        // í„°ë¯¸ë„ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ ì½˜ì†”ì—ë§Œ ì¶œë ¥
                        return;
                    }
                }
                
                try {
                    const line = document.createElement('div');
                    line.className = 'terminal-line';
                    line.textContent = `[${timestamp}] ${message}`;
                    this.elements.terminal.appendChild(line);
                    this.elements.terminal.scrollTop = this.elements.terminal.scrollHeight;
                    
                    // í„°ë¯¸ë„ ë¼ì¸ ìˆ˜ ì œí•œ (ì„±ëŠ¥ì„ ìœ„í•´)
                    const lines = this.elements.terminal.children;
                    if (lines.length > 100) {
                        lines[0].remove();
                    }
                } catch (error) {
                    console.error('í„°ë¯¸ë„ ë¡œê·¸ ì˜¤ë¥˜:', error);
                }
            }

            async runDiagnostics() {
                this.logToTerminal('ğŸ”§ ì‹œìŠ¤í…œ ì§„ë‹¨ ì‹œì‘...');
                
                // ë¸Œë¼ìš°ì € ì •ë³´
                this.logToTerminal(`ğŸŒ ë¸Œë¼ìš°ì €: ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
                this.logToTerminal(`ğŸ”’ í”„ë¡œí† ì½œ: ${window.location.protocol}`);
                this.logToTerminal(`ğŸ“ ì£¼ì†Œ: ${window.location.href}`);
                
                // WebSerial ì§€ì› í™•ì¸
                if ('serial' in navigator) {
                    this.logToTerminal('âœ… WebSerial API ì§€ì›ë¨');
                    
                    // Permissions API í™•ì¸ (ì•ˆì „í•˜ê²Œ)
                    if ('permissions' in navigator) {
                        try {
                            // ì¼ë¶€ ë¸Œë¼ìš°ì €ì—ì„œëŠ” 'serial' ê¶Œí•œ í™•ì¸ì´ ì§€ì›ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
                            const permission = await navigator.permissions.query({ name: 'serial' });
                            this.logToTerminal(`ğŸ” Serial ê¶Œí•œ ìƒíƒœ: ${permission.state}`);
                        } catch (error) {
                            this.logToTerminal(`âš ï¸  Serial ê¶Œí•œ í™•ì¸ ë¯¸ì§€ì› (ë¸Œë¼ìš°ì € ì œí•œ)`);
                        }
                    }
                } else {
                    this.logToTerminal('âŒ WebSerial API ë¯¸ì§€ì›');
                    this.logToTerminal('ğŸ’¡ í•´ê²°ë°©ë²•: Chrome 89+ ë˜ëŠ” Edge 89+ ì‚¬ìš©');
                }
                
                // HTTPS í™•ì¸ ë° í•´ê²°ë°©ë²• ì œì‹œ
                if (window.location.protocol === 'https:') {
                    this.logToTerminal('âœ… HTTPS í™˜ê²½ (WebSerial ì‚¬ìš© ê°€ëŠ¥)');
                } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    this.logToTerminal('âš ï¸  localhost HTTP í™˜ê²½');
                    this.logToTerminal('ğŸ’¡ localhostì—ì„œëŠ” WebSerialì´ ì œí•œì ìœ¼ë¡œ ì‘ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
                    this.logToTerminal('ğŸ’¡ ê¶Œì¥: https://localhost ë˜ëŠ” ì˜¨ë¼ì¸ HTTPS í™˜ê²½ ì‚¬ìš©');
                } else {
                    this.logToTerminal('âŒ HTTP í™˜ê²½ (WebSerial ì‚¬ìš© ë¶ˆê°€)');
                    this.logToTerminal('ğŸ’¡ í•´ê²°ë°©ë²•:');
                    this.logToTerminal('   1. ì£¼ì†Œì°½ì—ì„œ httpë¥¼ httpsë¡œ ë³€ê²½');
                    this.logToTerminal('   2. ë˜ëŠ” localhost í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸');
                    this.logToTerminal('   3. ë˜ëŠ” GitHub Pages ë“± HTTPS í˜¸ìŠ¤íŒ… ì‚¬ìš©');
                }
                
                // ì¶”ê°€ í™˜ê²½ ì •ë³´
                this.logToTerminal(`ğŸ–¥ï¸  User Agent: ${navigator.userAgent}`);
                this.logToTerminal(`ğŸŒ ì–¸ì–´: ${navigator.language}`);
                this.logToTerminal(`ğŸ“± í”Œë«í¼: ${navigator.platform}`);
                
                this.logToTerminal('âœ… ì‹œìŠ¤í…œ ì§„ë‹¨ ì™„ë£Œ');
                this.logToTerminal('');
                this.logToTerminal('ğŸš€ HTTPS í™˜ê²½ì—ì„œ ì ‘ì†í•˜ë©´ ì‹¤ì œ ì¥ë¹„ ì—°ê²°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤!');
            }

            async listAvailablePorts() {
                if (this.simulationMode) {
                    this.logToTerminal('âŒ WebSerial ë¯¸ì§€ì›ìœ¼ë¡œ í¬íŠ¸ í™•ì¸ ë¶ˆê°€');
                    return;
                }
                
                try {
                    this.logToTerminal('ğŸ” ì‚¬ìš©ê°€ëŠ¥í•œ í¬íŠ¸ ê²€ìƒ‰ ì¤‘...');
                    const ports = await navigator.serial.getPorts();
                    
                    if (ports.length === 0) {
                        this.logToTerminal('ğŸ“‹ ê¶Œí•œ ë¶€ì—¬ëœ í¬íŠ¸ ì—†ìŒ');
                        this.logToTerminal('ğŸ’¡ "ì¥ë¹„ ì—°ê²°" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í¬íŠ¸ ê¶Œí•œ ë¶€ì—¬');
                    } else {
                        this.logToTerminal(`ğŸ“‹ ë°œê²¬ëœ í¬íŠ¸: ${ports.length}ê°œ`);
                        
                        for (let i = 0; i < ports.length; i++) {
                            const port = ports[i];
                            const info = port.getInfo();
                            this.logToTerminal(`  í¬íŠ¸ ${i + 1}: VID=0x${info.usbVendorId?.toString(16) || 'unknown'}, PID=0x${info.usbProductId?.toString(16) || 'unknown'}`);
                            
                            if (info.usbVendorId === 0x0483 && info.usbProductId === 0x5740) {
                                this.logToTerminal('    âœ… tinySA/NanoVNA í˜¸í™˜!');
                            }
                        }
                    }
                } catch (error) {
                    this.logToTerminal(`âŒ í¬íŠ¸ ê²€ìƒ‰ ì‹¤íŒ¨: ${error.message}`);
                }
            }

            async testConnection() {
                if (this.simulationMode) {
                    this.logToTerminal('âŒ WebSerial ë¯¸ì§€ì›ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸ ë¶ˆê°€');
                    return;
                }
                
                this.logToTerminal('ğŸ§ª ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹œì‘...');
                
                try {
                    // í¬íŠ¸ ì„ íƒ
                    this.logToTerminal('ğŸ“‹ í…ŒìŠ¤íŠ¸ìš© í¬íŠ¸ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ...');
                    const testPort = await navigator.serial.requestPort({
                        filters: [{ usbVendorId: 0x0483, usbProductId: 0x5740 }]
                    });
                    
                    this.logToTerminal('âœ… í¬íŠ¸ ì„ íƒ ì™„ë£Œ');
                    
                    // í¬íŠ¸ ì—´ê¸°
                    this.logToTerminal('ğŸ”— í¬íŠ¸ ì—´ê¸° ì‹œë„...');
                    await testPort.open({
                        baudRate: 115200,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none'
                    });
                    
                    this.logToTerminal('âœ… í¬íŠ¸ ì—´ê¸° ì„±ê³µ');
                    
                    // ê°„ë‹¨í•œ ëª…ë ¹ í…ŒìŠ¤íŠ¸
                    this.logToTerminal('ğŸ“¤ í…ŒìŠ¤íŠ¸ ëª…ë ¹ ì „ì†¡ (info)...');
                    const encoder = new TextEncoder();
                    const decoder = new TextDecoder();
                    
                    const writer = testPort.writable.getWriter();
                    await writer.write(encoder.encode('info\r\n'));
                    writer.releaseLock();
                    
                    // ì‘ë‹µ ì½ê¸° (íƒ€ì„ì•„ì›ƒ í¬í•¨)
                    const reader = testPort.readable.getReader();
                    const timeout = setTimeout(() => reader.cancel(), 2000);
                    
                    try {
                        const { value } = await reader.read();
                        clearTimeout(timeout);
                        
                        if (value) {
                            const response = decoder.decode(value);
                            this.logToTerminal(`ğŸ“¥ ì¥ë¹„ ì‘ë‹µ: ${response.trim()}`);
                            this.logToTerminal('âœ… í†µì‹  í…ŒìŠ¤íŠ¸ ì„±ê³µ!');
                        } else {
                            this.logToTerminal('âš ï¸  ì‘ë‹µ ì—†ìŒ (ì¼ë¶€ ì¥ë¹„ì—ì„œ ì •ìƒ)');
                        }
                    } catch (readError) {
                        this.logToTerminal(`âš ï¸  ì‘ë‹µ ì½ê¸° ì‹¤íŒ¨: ${readError.message}`);
                    }
                    
                    reader.releaseLock();
                    
                    // í¬íŠ¸ ë‹«ê¸°
                    await testPort.close();
                    this.logToTerminal('ğŸ”’ í…ŒìŠ¤íŠ¸ í¬íŠ¸ ë‹«ê¸° ì™„ë£Œ');
                    this.logToTerminal('ğŸ‰ ì—°ê²° í…ŒìŠ¤íŠ¸ ì™„ë£Œ!');
                    
                } catch (error) {
                    this.logToTerminal(`âŒ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.name} - ${error.message}`);
                    
                    if (error.name === 'NotFoundError') {
                        this.logToTerminal('ğŸ’¡ í•´ê²°ë°©ë²•: USB ì¼€ì´ë¸”ê³¼ ì¥ë¹„ ì—°ê²° í™•ì¸');
                    } else if (error.name === 'SecurityError') {
                        this.logToTerminal('ğŸ’¡ í•´ê²°ë°©ë²•: HTTPS í™˜ê²½ì—ì„œ ì ‘ì†');
                    } else if (error.name === 'InvalidStateError') {
                        this.logToTerminal('ğŸ’¡ í•´ê²°ë°©ë²•: ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì¥ë¹„ ì‚¬ìš© ì¤‘ì¼ ìˆ˜ ìˆìŒ');
                    }
                }
            }

            saveScreenshot() {
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `${this.deviceType}_${timestamp}.png`;
                
                this.canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.logToTerminal(`ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ì €ì¥: ${filename}`);
                });
            }

            async sendDeviceCommand(command) {
                if (!this.simulationMode && this.serialPort) {
                    try {
                        const encoder = new TextEncoder();
                        const writer = this.serialPort.writable.getWriter();
                        await writer.write(encoder.encode(command + '\r\n'));
                        writer.releaseLock();
                    } catch (error) {
                        console.error('ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨:', error);
                    }
                }
            }

            showHttpsGuide() {
                this.logToTerminal('ğŸ“– HTTPS ì„¤ì • ê°€ì´ë“œ');
                this.logToTerminal('');
                this.logToTerminal('ğŸ”’ WebSerial APIëŠ” ë³´ì•ˆìƒ HTTPS í™˜ê²½ì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤.');
                this.logToTerminal('');
                this.logToTerminal('ğŸ“‹ í•´ê²°ë°©ë²•:');
                this.logToTerminal('');
                this.logToTerminal('1ï¸âƒ£  ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•:');
                this.logToTerminal('   - ì£¼ì†Œì°½ì—ì„œ "http://"ë¥¼ "https://"ë¡œ ë³€ê²½');
                this.logToTerminal('   - ì˜ˆ: https://example.com/tinysa_remote.html');
                this.logToTerminal('');
                this.logToTerminal('2ï¸âƒ£  ë¡œì»¬ HTTPS ì„œë²„ ì‚¬ìš©:');
                this.logToTerminal('   - Python 3.7+: python -m http.server --bind localhost 8443');
                this.logToTerminal('   - ë˜ëŠ” Node.jsì˜ http-server ì‚¬ìš©');
                this.logToTerminal('   - ë¸Œë¼ìš°ì €ì—ì„œ https://localhost:8443 ì ‘ì†');
                this.logToTerminal('');
                this.logToTerminal('3ï¸âƒ£  ë¬´ë£Œ HTTPS í˜¸ìŠ¤íŒ…:');
                this.logToTerminal('   - GitHub Pages (github.io)');
                this.logToTerminal('   - Netlify, Vercel ë“±');
                this.logToTerminal('   - CodePen, JSFiddle (ì œí•œì )');
                this.logToTerminal('');
                this.logToTerminal('4ï¸âƒ£  ë¡œì»¬ ê°œë°œ í™˜ê²½:');
                this.logToTerminal('   - VS Code Live Server í™•ì¥ + HTTPS ì„¤ì •');
                this.logToTerminal('   - Chrome --allow-running-insecure-content í”Œë˜ê·¸ (ë¹„ì¶”ì²œ)');
                this.logToTerminal('');
                this.logToTerminal('ğŸ¯ ê¶Œì¥ì‚¬í•­:');
                this.logToTerminal('   í˜„ì¬ íŒŒì¼ì„ GitHubì— ì—…ë¡œë“œí•˜ê³  GitHub Pagesë¡œ í˜¸ìŠ¤íŒ…í•˜ë©´');
                this.logToTerminal('   https://yourusername.github.io/repo-name/ ìœ¼ë¡œ ì ‘ì† ê°€ëŠ¥');
                this.logToTerminal('');
                this.logToTerminal('ğŸ’¡ í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ UI í…ŒìŠ¤íŠ¸ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤!');
            }

            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    this.elements.fpsCounter.textContent = `FPS: ${this.fps}`;
                    this.elements.fpsValue.textContent = this.fps.toString();
                }
            }
        }

        // ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM ë¡œë“œ ì™„ë£Œ - tinySA ë¦¬ëª¨íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ ì‹œì‘');
            window.controller = new NanoVNARemoteController();
        });
    </script>
</body>
</html>
